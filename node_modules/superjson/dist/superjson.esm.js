import { find, includes, entries, fromPairs, forEach, every, values, mapValues } from 'lodash-es';

var getType = function getType(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
};

var isUndefined = function isUndefined(payload) {
  return getType(payload) === 'Undefined';
};
var isNull = function isNull(payload) {
  return getType(payload) === 'Null';
};
var isPlainObject = function isPlainObject(payload) {
  if (getType(payload) !== 'Object') return false;
  return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;
};
var isEmptyObject = function isEmptyObject(payload) {
  return isPlainObject(payload) && Object.keys(payload).length === 0;
};
var isArray = function isArray(payload) {
  return getType(payload) === 'Array';
};
var isString = function isString(payload) {
  return getType(payload) === 'String';
};
var isNumber = function isNumber(payload) {
  return getType(payload) === 'Number' && !isNaN(payload);
};
var isBoolean = function isBoolean(payload) {
  return getType(payload) === 'Boolean';
};
var isRegExp = function isRegExp(payload) {
  return getType(payload) === 'RegExp';
};
var isMap = function isMap(payload) {
  return getType(payload) === 'Map';
};
var isSet = function isSet(payload) {
  return getType(payload) === 'Set';
};
var isSymbol = function isSymbol(payload) {
  return getType(payload) === 'Symbol';
};
var isDate = function isDate(payload) {
  return getType(payload) === 'Date' && !isNaN(payload);
};
var isNaNValue = function isNaNValue(payload) {
  return getType(payload) === 'Number' && isNaN(payload);
};
var isPrimitive = function isPrimitive(payload) {
  return isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload);
};
var isBigint = function isBigint(payload) {
  return getType(payload) === 'BigInt';
};
var isInfinite = function isInfinite(payload) {
  return payload === Infinity || payload === -Infinity;
};

var getNthKey = function getNthKey(value, n) {
  var keys = value.keys();

  while (n > 0) {
    keys.next();
    n--;
  }

  return keys.next().value;
};
var getDeep = function getDeep(object, path) {
  path.forEach(function (key) {
    object = object[key];
  });
  return object;
};
var setDeep = function setDeep(object, path, mapper) {
  if (path.length === 0) {
    return mapper(object);
  }

  var parent = object;

  for (var i = 0; i < path.length - 1; i++) {
    var key = path[i];

    if (isArray(parent)) {
      var index = +key;
      parent = parent[index];
    } else if (isPlainObject(parent)) {
      parent = parent[key];
    } else if (isSet(parent)) {
      var row = +key;
      parent = getNthKey(parent, row);
    } else if (isMap(parent)) {
      var isEnd = i === path.length - 2;

      if (isEnd) {
        break;
      }

      var _row = +key;

      var type = +path[i + 1] === 0 ? 'key' : 'value';
      var keyOfRow = getNthKey(parent, _row);

      switch (type) {
        case 'key':
          parent = keyOfRow;
          break;

        case 'value':
          parent = parent.get(keyOfRow);
          break;
      }

      i++;
    }
  }

  var lastKey = path[path.length - 1];

  if (isArray(parent) || isPlainObject(parent)) {
    parent[lastKey] = mapper(parent[lastKey]);
  }

  if (isSet(parent)) {
    var oldValue = getNthKey(parent, +lastKey);
    var newValue = mapper(oldValue);

    if (oldValue !== newValue) {
      parent["delete"](oldValue);
      parent.add(newValue);
    }
  }

  if (isMap(parent)) {
    var _row2 = +path[path.length - 2];

    var keyToRow = getNthKey(parent, _row2);

    var _type = +lastKey === 0 ? 'key' : 'value';

    switch (_type) {
      case 'key':
        {
          var newKey = mapper(keyToRow);
          parent.set(newKey, parent.get(keyToRow));

          if (newKey !== keyToRow) {
            parent["delete"](keyToRow);
          }

          break;
        }

      case 'value':
        {
          parent.set(keyToRow, mapper(parent.get(keyToRow)));
          break;
        }
    }
  }

  return object;
};

var DoubleIndexedKV = /*#__PURE__*/function () {
  function DoubleIndexedKV() {
    this.keyToValue = new Map();
    this.valueToKey = new Map();
  }

  var _proto = DoubleIndexedKV.prototype;

  _proto.set = function set(key, value) {
    this.keyToValue.set(key, value);
    this.valueToKey.set(value, key);
  };

  _proto.deleteByValue = function deleteByValue(value) {
    var _this = this;

    this.valueToKey["delete"](value);
    this.keyToValue.forEach(function (otherValue, otherKey) {
      if (value === otherValue) {
        _this.keyToValue["delete"](otherKey);
      }
    });
  };

  _proto.getByKey = function getByKey(key) {
    return this.keyToValue.get(key);
  };

  _proto.getByValue = function getByValue(value) {
    return this.valueToKey.get(value);
  };

  _proto.clear = function clear() {
    this.keyToValue.clear();
    this.valueToKey.clear();
  };

  return DoubleIndexedKV;
}();

var Registry = /*#__PURE__*/function () {
  function Registry(generateIdentifier) {
    this.generateIdentifier = generateIdentifier;
    this.kv = new DoubleIndexedKV();
  }

  var _proto = Registry.prototype;

  _proto.register = function register(value, identifier) {
    if (this.kv.getByValue(value)) {
      return;
    }

    if (!identifier) {
      identifier = this.generateIdentifier(value);
    }

    if (this.kv.getByKey(identifier)) {
      throw new Error('Ambiguous class, provide a unique identifier.');
    }

    this.kv.set(identifier, value);
  };

  _proto.unregister = function unregister(v) {
    this.kv.deleteByValue(v);
  };

  _proto.clear = function clear() {
    this.kv.clear();
  };

  _proto.getIdentifier = function getIdentifier(value) {
    return this.kv.getByValue(value);
  };

  _proto.getValue = function getValue(identifier) {
    return this.kv.getByKey(identifier);
  };

  return Registry;
}();

var ClassRegistry = /*#__PURE__*/new Registry(function (c) {
  return c.name;
});

var SymbolRegistry = /*#__PURE__*/new Registry(function (s) {
  var _s$description;

  return (_s$description = s.description) !== null && _s$description !== void 0 ? _s$description : '';
});

var ALL_PRIMITIVE_TYPE_ANNOTATIONS = ['undefined', 'number', 'bigint'];
var ALL_TYPE_ANNOTATIONS = /*#__PURE__*/ALL_PRIMITIVE_TYPE_ANNOTATIONS.concat(['map', 'regexp', 'set', 'Date']);
var isTypeAnnotation = function isTypeAnnotation(value) {
  if (Array.isArray(value)) {
    return typeof value[1] === 'string';
  }

  return includes(ALL_TYPE_ANNOTATIONS, value);
};

function simpleTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable: isApplicable,
    annotation: annotation,
    transform: transform,
    untransform: untransform
  };
}

var simpleRules = [/*#__PURE__*/simpleTransformation(isUndefined, 'undefined', function () {
  return null;
}, function () {
  return undefined;
}), /*#__PURE__*/simpleTransformation(isBigint, 'bigint', function (v) {
  return v.toString();
}, function (v) {
  if (typeof BigInt !== 'undefined') {
    return BigInt(v);
  }

  console.error('Please add a BigInt polyfill.');
  return v;
}), /*#__PURE__*/simpleTransformation(isDate, 'Date', function (v) {
  return v.toISOString();
}, function (v) {
  return new Date(v);
}), /*#__PURE__*/simpleTransformation(isRegExp, 'regexp', function (v) {
  return '' + v;
}, function (regex) {
  var body = regex.slice(1, regex.lastIndexOf('/'));
  var flags = regex.slice(regex.lastIndexOf('/') + 1);
  return new RegExp(body, flags);
}), /*#__PURE__*/simpleTransformation(isSet, 'set', function (v) {
  return entries(v).map(function (_ref) {
    var value = _ref[0];
    return value;
  });
}, function (v) {
  return new Set(v);
}), /*#__PURE__*/simpleTransformation(isMap, 'map', function (v) {
  return entries(v);
}, function (v) {
  return new Map(v);
}), /*#__PURE__*/simpleTransformation(function (v) {
  return isNaNValue(v) || isInfinite(v);
}, 'number', function (v) {
  if (isNaNValue(v)) {
    return 'NaN';
  }

  if (v > 0) {
    return 'Infinity';
  } else {
    return '-Infinity';
  }
}, Number)];

function compositeTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable: isApplicable,
    annotation: annotation,
    transform: transform,
    untransform: untransform
  };
}

var symbolRule = /*#__PURE__*/compositeTransformation(function (s) {
  if (isSymbol(s)) {
    var isRegistered = !!SymbolRegistry.getIdentifier(s);
    return isRegistered;
  }

  return false;
}, function (s) {
  var identifier = SymbolRegistry.getIdentifier(s);
  return ['symbol', identifier];
}, function (v) {
  return v.description;
}, function (_, a) {
  var value = SymbolRegistry.getValue(a[1]);

  if (!value) {
    throw new Error('Trying to deserialize unknown symbol');
  }

  return value;
});
var classRule = /*#__PURE__*/compositeTransformation(function (potentialClass) {
  if (potentialClass === null || potentialClass === void 0 ? void 0 : potentialClass.constructor) {
    var isRegistered = !!ClassRegistry.getIdentifier(potentialClass.constructor);
    return isRegistered;
  }

  return false;
}, function (clazz) {
  var identifier = ClassRegistry.getIdentifier(clazz.constructor);
  return ['class', identifier];
}, function (v) {
  return v;
}, function (v, a) {
  var clazz = ClassRegistry.getValue(a[1]);

  if (!clazz) {
    throw new Error('Trying to deserialize unknown class');
  }

  return Object.assign(Object.create(clazz.prototype), v);
});
var compositeRules = [classRule, symbolRule];
var transformValue = function transformValue(value) {
  var applicableSimpleRule = find(simpleRules, function (rule) {
    return rule.isApplicable(value);
  });

  if (applicableSimpleRule) {
    return {
      value: applicableSimpleRule.transform(value),
      type: applicableSimpleRule.annotation
    };
  }

  var applicableCompositeRule = find(compositeRules, function (rule) {
    return rule.isApplicable(value);
  });

  if (applicableCompositeRule) {
    return {
      value: applicableCompositeRule.transform(value),
      type: applicableCompositeRule.annotation(value)
    };
  }

  return undefined;
};
var simpleRulesByAnnotation = /*#__PURE__*/fromPairs( /*#__PURE__*/simpleRules.map(function (r) {
  return [r.annotation, r];
}));
var untransformValue = function untransformValue(json, type) {
  if (isArray(type)) {
    switch (type[0]) {
      case 'symbol':
        return symbolRule.untransform(json, type);

      case 'class':
        return classRule.untransform(json, type);

      default:
        throw new Error('Unknown transformation: ' + type);
    }
  } else {
    var transformation = simpleRulesByAnnotation[type];

    if (!transformation) {
      throw new Error('Unknown transformation: ' + type);
    }

    return transformation.untransform(json);
  }
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var escapeKey = function escapeKey(key) {
  return key.replace(/\./g, '\\.');
};
var stringifyPath = function stringifyPath(path) {
  return path.map(String).map(escapeKey).join('.');
};
var parsePath = function parsePath(string) {
  var result = [];
  var segment = '';

  for (var i = 0; i < string.length; i++) {
    var _char = string.charAt(i);

    var isEscapedDot = _char === '\\' && string.charAt(i + 1) === '.';

    if (isEscapedDot) {
      segment += '.';
      i++;
      continue;
    }

    var isEndOfSegment = _char === '.';

    if (isEndOfSegment) {
      result.push(segment);
      segment = '';
      continue;
    }

    segment += _char;
  }

  var lastSegment = segment;
  result.push(lastSegment);
  return result;
};

function isTree(v, valueChecker) {
  if (!isArray(v)) {
    return false;
  }

  if (v.length === 1) {
    return valueChecker(v[0]);
  } else if (v.length === 2) {
    return valueChecker(v[0]) && every(v[1], function (v) {
      return isTree(v, valueChecker);
    });
  }

  return false;
}

function isPrefixOf(potentialPrefix, of) {
  if (potentialPrefix.length > of.length) {
    return false;
  }

  return potentialPrefix.every(function (value, index) {
    return value === of[index];
  });
}

var PathTree;

(function (PathTree) {
  function create(value) {
    return [value];
  }

  PathTree.create = create;

  function get(tree, path) {
    if (path.length === 0) {
      return [tree[0], true];
    }

    if (tree.length === 1) {
      return [null, false];
    } else {
      var head = path[0],
          tail = path.slice(1);
      var children = tree[1];
      return get(children[head], tail);
    }
  }

  PathTree.get = get;
  /**
   * @description Optimised for adding new leaves. Does not support adding inner nodes.
   */

  function append(tree, path, value) {
    if (path.length === 0) {
      if (tree.length === 1) {
        return [value];
      } else {
        var children = tree[1];
        return [value, children];
      }
    }

    if (tree.length === 1) {
      var _ref;

      var nodeValue = tree[0];
      return [nodeValue, (_ref = {}, _ref[stringifyPath(path)] = [value], _ref)];
    } else {
      var _nodeValue = tree[0],
          _children = tree[1];
      var availablePaths = Object.keys(_children); // due to the constraints mentioned in the functions description,
      // there may be prefixes of `path` already set, but no extensions of it.
      // If there's such a prefix, we'll find it.

      var prefix = find(availablePaths, function (candidate) {
        return isPrefixOf(parsePath(candidate), path);
      });

      if (isUndefined(prefix)) {
        var _extends2;

        return [_nodeValue, _extends({}, _children, (_extends2 = {}, _extends2[stringifyPath(path)] = [value], _extends2))];
      } else {
        var _extends3;

        var pathWithoutPrefix = path.slice(parsePath(prefix).length);
        return [_nodeValue, _extends({}, _children, (_extends3 = {}, _extends3[prefix] = append(_children[prefix], pathWithoutPrefix, value), _extends3))];
      }
    }
  }

  PathTree.append = append;

  function appendPath(tree, path) {
    var front = path.slice(0, path.length - 1);
    var last = path[path.length - 1];
    return append(tree, front, last);
  }

  PathTree.appendPath = appendPath;
  /**
   * Depth-first post-order traversal.
   */

  function traverse(tree, walker, origin) {
    if (origin === void 0) {
      origin = [];
    }

    if (tree.length === 1) {
      var nodeValue = tree[0];
      walker(nodeValue, origin);
    } else {
      var _nodeValue2 = tree[0],
          children = tree[1];
      forEach(children, function (child, key) {
        traverse(child, walker, [].concat(origin, parsePath(key)));
      });
      walker(_nodeValue2, origin);
    }
  }

  PathTree.traverse = traverse;

  function traverseWhileIgnoringNullRoot(tree, walker) {
    traverse(tree, function (v, path) {
      if (isNull(v)) {
        if (path.length === 0) {
          return;
        }

        throw new Error('Illegal State');
      }

      walker(v, path);
    });
  }

  PathTree.traverseWhileIgnoringNullRoot = traverseWhileIgnoringNullRoot;

  function traversePaths(tree, walker) {
    traverseWhileIgnoringNullRoot(tree, function (last, front) {
      return walker([].concat(front, [last]));
    });
  }

  PathTree.traversePaths = traversePaths;

  function isMinimizedTree(v, valueChecker) {
    if (isUndefined(v)) {
      return true;
    }

    if (isPlainObject(v)) {
      return every(v, function (v) {
        return isTree(v, valueChecker);
      });
    }

    return isTree(v, valueChecker);
  }

  PathTree.isMinimizedTree = isMinimizedTree;
  /**
   * @description Minimizes trees that start with a `null`-root
   */

  function collapseRoot(tree) {
    if (isNull(tree[0])) {
      if (tree.length === 1) {
        return undefined;
      } else {
        return tree[1];
      }
    }

    return tree;
  }

  PathTree.collapseRoot = collapseRoot;

  function expandRoot(tree) {
    if (isArray(tree)) {
      return tree;
    }

    if (isUndefined(tree)) {
      return [null];
    }

    return [null, tree];
  }

  PathTree.expandRoot = expandRoot;
})(PathTree || (PathTree = {}));

function isAnnotations(object) {
  try {
    if (object.values) {
      if (!PathTree.isMinimizedTree(object.values, isTypeAnnotation)) {
        return false;
      }
    }

    if (object.referentialEqualities) {
      if (!PathTree.isMinimizedTree(object.referentialEqualities, function (tree) {
        return PathTree.isMinimizedTree(tree, isString);
      })) {
        return false;
      }
    }

    return true;
  } catch (error) {
    return false;
  }
}

var ValueAnnotationFactory = /*#__PURE__*/function () {
  function ValueAnnotationFactory() {
    this.tree = PathTree.create(null);
  }

  var _proto = ValueAnnotationFactory.prototype;

  _proto.add = function add(path, annotation) {
    this.tree = PathTree.append(this.tree, path.map(String), annotation);
  };

  _proto.create = function create() {
    return PathTree.collapseRoot(this.tree);
  };

  return ValueAnnotationFactory;
}();

var ReferentialEqualityAnnotationFactory = /*#__PURE__*/function () {
  function ReferentialEqualityAnnotationFactory() {
    this.objectIdentities = new Map();
  }

  var _proto2 = ReferentialEqualityAnnotationFactory.prototype;

  _proto2.register = function register(object, path) {
    var _this$objectIdentitie;

    var paths = (_this$objectIdentitie = this.objectIdentities.get(object)) !== null && _this$objectIdentitie !== void 0 ? _this$objectIdentitie : [];
    paths.push(path);
    this.objectIdentities.set(object, paths);
  };

  _proto2.create = function create() {
    var tree = PathTree.create(null);
    this.objectIdentities.forEach(function (paths) {
      if (paths.length <= 1) {
        return;
      }

      var _paths$map$sort = paths.map(function (path) {
        return path.map(String);
      }).sort(function (a, b) {
        return a.length - b.length;
      }),
          shortestPath = _paths$map$sort[0],
          identicalPaths = _paths$map$sort.slice(1);

      var identities = PathTree.create(null);
      identicalPaths.forEach(function (identicalPath) {
        identities = PathTree.appendPath(identities, identicalPath);
      });
      var minimizedIdentities = PathTree.collapseRoot(identities);

      if (!minimizedIdentities) {
        throw new Error('Illegal State');
      }

      tree = PathTree.append(tree, shortestPath, minimizedIdentities);
    });
    return PathTree.collapseRoot(tree);
  };

  return ReferentialEqualityAnnotationFactory;
}();

var AnnotationFactory = /*#__PURE__*/function () {
  function AnnotationFactory() {
    this.valueAnnotations = new ValueAnnotationFactory();
    this.objectIdentities = new ReferentialEqualityAnnotationFactory();
  }

  var _proto3 = AnnotationFactory.prototype;

  _proto3.create = function create() {
    var annotations = {};
    var values = this.valueAnnotations.create();

    if (values) {
      annotations.values = values;
    }

    var referentialEqualities = this.objectIdentities.create();

    if (referentialEqualities) {
      annotations.referentialEqualities = referentialEqualities;
    }

    return annotations;
  };

  return AnnotationFactory;
}();

var makeAnnotator = function makeAnnotator() {
  var annotationFactory = new AnnotationFactory();
  var valueAnnotations = annotationFactory.valueAnnotations,
      objectIdentities = annotationFactory.objectIdentities;

  var annotator = function annotator(_ref) {
    var path = _ref.path,
        node = _ref.node;

    if (!isPrimitive(node)) {
      objectIdentities.register(node, path);
    }

    var transformed = transformValue(node);

    if (transformed) {
      valueAnnotations.add(path, transformed.type);
      return transformed.value;
    } else {
      return node;
    }
  };

  return {
    getAnnotations: function getAnnotations() {
      return annotationFactory.create();
    },
    annotator: annotator
  };
};
var applyAnnotations = function applyAnnotations(plain, annotations) {
  if (annotations.values) {
    PathTree.traverseWhileIgnoringNullRoot(PathTree.expandRoot(annotations.values), function (type, path) {
      plain = setDeep(plain, path, function (v) {
        return untransformValue(v, type);
      });
    });
  }

  if (annotations.referentialEqualities) {
    PathTree.traverseWhileIgnoringNullRoot(PathTree.expandRoot(annotations.referentialEqualities), function (identicalObjects, path) {
      var object = getDeep(plain, path);
      PathTree.traversePaths(PathTree.expandRoot(identicalObjects), function (identicalObjectPath) {
        plain = setDeep(plain, identicalObjectPath, function () {
          return object;
        });
      });
    });
  }

  return plain;
};

var isDeep = function isDeep(object) {
  return isPlainObject(object) || isArray(object) || isMap(object) || isSet(object);
};

var plainer = function plainer(object, walker, path, alreadySeenObjects) {
  if (path === void 0) {
    path = [];
  }

  if (alreadySeenObjects === void 0) {
    alreadySeenObjects = [];
  }

  if (!isDeep(object)) {
    return walker({
      isLeaf: true,
      node: object,
      path: path
    });
  }

  walker({
    isLeaf: false,
    path: path,
    node: object
  });

  if (includes(alreadySeenObjects, object)) {
    return null;
  }

  if (!isPrimitive(object)) {
    alreadySeenObjects = [].concat(alreadySeenObjects, [object]);
  }

  if (isArray(object)) {
    return values(object).map(function (value, index) {
      return plainer(value, walker, [].concat(path, [index]), alreadySeenObjects);
    });
  }

  if (isSet(object)) {
    return entries(object).map(function (_ref, index) {
      var value = _ref[0];
      return plainer(value, walker, [].concat(path, [index]), alreadySeenObjects);
    });
  }

  if (isMap(object)) {
    return entries(object).map(function (_ref2, index) {
      var key = _ref2[0],
          value = _ref2[1];
      return [plainer(key, walker, [].concat(path, [index, 0]), alreadySeenObjects), plainer(value, walker, [].concat(path, [index, 1]), alreadySeenObjects)];
    });
  }

  if (isPlainObject(object)) {
    return mapValues(object, function (value, key) {
      return plainer(value, walker, [].concat(path, [key]), alreadySeenObjects);
    });
  }
};

function isSuperJSONResult(object) {
  if (!('json' in object)) {
    return false;
  }

  if (isUndefined(object.meta)) {
    return true;
  }

  return isAnnotations(object.meta);
}

var serialize = function serialize(object) {
  var _makeAnnotator = makeAnnotator(),
      getAnnotations = _makeAnnotator.getAnnotations,
      annotator = _makeAnnotator.annotator;

  var output = plainer(object, annotator);
  var annotations = getAnnotations();
  return {
    json: output,
    meta: isEmptyObject(annotations) ? undefined : annotations
  };
};
var deserialize = function deserialize(payload) {
  if (!isSuperJSONResult(payload)) {
    throw new Error('Not a valid SuperJSON payload.');
  }

  var json = payload.json,
      meta = payload.meta;
  var result = json;

  if (!!meta) {
    return applyAnnotations(result, meta);
  }

  return result;
};

var stringify = function stringify(object) {
  return JSON.stringify(serialize(object));
};

var parse = function parse(string) {
  return deserialize(JSON.parse(string));
};

var registerClass = function registerClass(v, identifier) {
  return ClassRegistry.register(v, identifier);
};

var unregisterClass = function unregisterClass(v) {
  return ClassRegistry.unregister(v);
};

var registerSymbol = function registerSymbol(v, identifier) {
  return SymbolRegistry.register(v, identifier);
};

var unregisterSymbol = function unregisterSymbol(v) {
  return SymbolRegistry.unregister(v);
};

var index = {
  stringify: stringify,
  parse: parse,
  serialize: serialize,
  deserialize: deserialize,
  registerClass: registerClass,
  unregisterClass: unregisterClass,
  registerSymbol: registerSymbol,
  unregisterSymbol: unregisterSymbol
};

export default index;
export { deserialize, parse, serialize };
//# sourceMappingURL=superjson.esm.js.map
