{"version":3,"file":"superjson.cjs.development.js","sources":["../src/is.ts","../src/accessDeep.ts","../src/double-indexed-kv.ts","../src/registry.ts","../src/class-registry.ts","../src/symbol-registry.ts","../src/transformer.ts","../src/pathstringifier.ts","../src/pathtree.ts","../src/annotator.ts","../src/plainer.ts","../src/types.ts","../src/index.ts"],"sourcesContent":["const getType = (payload: any): string =>\n  Object.prototype.toString.call(payload).slice(8, -1);\n\nexport const isUndefined = (payload: any): payload is undefined =>\n  getType(payload) === 'Undefined';\n\nexport const isNull = (payload: any): payload is null =>\n  getType(payload) === 'Null';\n\nexport const isPlainObject = (\n  payload: any\n): payload is { [key: string]: any } => {\n  if (getType(payload) !== 'Object') return false;\n  return (\n    payload.constructor === Object &&\n    Object.getPrototypeOf(payload) === Object.prototype\n  );\n};\n\nexport const isEmptyObject = (payload: any): payload is {} =>\n  isPlainObject(payload) && Object.keys(payload).length === 0;\n\nexport const isArray = (payload: any): payload is any[] =>\n  getType(payload) === 'Array';\n\nexport const isString = (payload: any): payload is string =>\n  getType(payload) === 'String';\n\nexport const isNumber = (payload: any): payload is number =>\n  getType(payload) === 'Number' && !isNaN(payload);\n\nexport const isBoolean = (payload: any): payload is boolean =>\n  getType(payload) === 'Boolean';\n\nexport const isRegExp = (payload: any): payload is RegExp =>\n  getType(payload) === 'RegExp';\n\nexport const isMap = (payload: any): payload is Map<any, any> =>\n  getType(payload) === 'Map';\n\nexport const isSet = (payload: any): payload is Set<any> =>\n  getType(payload) === 'Set';\n\nexport const isSymbol = (payload: any): payload is symbol =>\n  getType(payload) === 'Symbol';\n\nexport const isDate = (payload: any): payload is Date =>\n  getType(payload) === 'Date' && !isNaN(payload);\n\nexport const isNaNValue = (payload: any): payload is typeof NaN =>\n  getType(payload) === 'Number' && isNaN(payload);\n\nexport const isPrimitive = (\n  payload: any\n): payload is boolean | null | undefined | number | string | symbol =>\n  isBoolean(payload) ||\n  isNull(payload) ||\n  isUndefined(payload) ||\n  isNumber(payload) ||\n  isString(payload) ||\n  isSymbol(payload);\n\nexport const isBigint = (payload: any): payload is bigint =>\n  getType(payload) === 'BigInt';\n\nexport const isInfinite = (payload: any): payload is number =>\n  payload === Infinity || payload === -Infinity;\n","import { isMap, isArray, isPlainObject, isSet } from './is';\n\nexport const getNthKey = (value: Map<any, any> | Set<any>, n: number): any => {\n  const keys = value.keys();\n  while (n > 0) {\n    keys.next();\n    n--;\n  }\n\n  return keys.next().value;\n};\n\nexport const getDeep = (object: object, path: (string | number)[]): object => {\n  path.forEach(key => {\n    object = (object as any)[key];\n  });\n\n  return object;\n};\n\nexport const setDeep = (\n  object: any,\n  path: (string | number)[],\n  mapper: (v: any) => any\n): any => {\n  if (path.length === 0) {\n    return mapper(object);\n  }\n\n  let parent = object;\n\n  for (let i = 0; i < path.length - 1; i++) {\n    const key = path[i];\n\n    if (isArray(parent)) {\n      const index = +key;\n      parent = parent[index];\n    } else if (isPlainObject(parent)) {\n      parent = parent[key];\n    } else if (isSet(parent)) {\n      const row = +key;\n      parent = getNthKey(parent, row);\n    } else if (isMap(parent)) {\n      const isEnd = i === path.length - 2;\n      if (isEnd) {\n        break;\n      }\n\n      const row = +key;\n      const type = +path[i + 1] === 0 ? 'key' : 'value';\n\n      const keyOfRow = getNthKey(parent, row);\n      switch (type) {\n        case 'key':\n          parent = keyOfRow;\n          break;\n        case 'value':\n          parent = parent.get(keyOfRow);\n          break;\n      }\n\n      i++;\n    }\n  }\n\n  const lastKey = path[path.length - 1];\n\n  if (isArray(parent) || isPlainObject(parent)) {\n    parent[lastKey] = mapper(parent[lastKey]);\n  }\n\n  if (isSet(parent)) {\n    const oldValue = getNthKey(parent, +lastKey);\n    const newValue = mapper(oldValue);\n    if (oldValue !== newValue) {\n      parent.delete(oldValue);\n      parent.add(newValue);\n    }\n  }\n\n  if (isMap(parent)) {\n    const row = +path[path.length - 2];\n    const keyToRow = getNthKey(parent, row);\n\n    const type = +lastKey === 0 ? 'key' : 'value';\n    switch (type) {\n      case 'key': {\n        const newKey = mapper(keyToRow);\n        parent.set(newKey, parent.get(keyToRow));\n\n        if (newKey !== keyToRow) {\n          parent.delete(keyToRow);\n        }\n        break;\n      }\n\n      case 'value': {\n        parent.set(keyToRow, mapper(parent.get(keyToRow)));\n        break;\n      }\n    }\n  }\n\n  return object;\n};\n","export class DoubleIndexedKV<K, V> {\n  keyToValue = new Map<K, V>();\n  valueToKey = new Map<V, K>();\n\n  set(key: K, value: V) {\n    this.keyToValue.set(key, value);\n    this.valueToKey.set(value, key);\n  }\n\n  deleteByValue(value: V) {\n    this.valueToKey.delete(value);\n    this.keyToValue.forEach((otherValue, otherKey) => {\n      if (value === otherValue) {\n        this.keyToValue.delete(otherKey);\n      }\n    });\n  }\n\n  getByKey(key: K): V | undefined {\n    return this.keyToValue.get(key);\n  }\n\n  getByValue(value: V): K | undefined {\n    return this.valueToKey.get(value);\n  }\n\n  clear() {\n    this.keyToValue.clear();\n    this.valueToKey.clear();\n  }\n}\n","import { DoubleIndexedKV } from './double-indexed-kv';\n\nexport class Registry<T> {\n  private kv = new DoubleIndexedKV<string, T>();\n\n  constructor(private readonly generateIdentifier: (v: T) => string) {}\n\n  register(value: T, identifier?: string): void {\n    if (this.kv.getByValue(value)) {\n      return;\n    }\n\n    if (!identifier) {\n      identifier = this.generateIdentifier(value);\n    }\n\n    if (this.kv.getByKey(identifier)) {\n      throw new Error('Ambiguous class, provide a unique identifier.');\n    }\n\n    this.kv.set(identifier, value);\n  }\n\n  unregister(v: T): void {\n    this.kv.deleteByValue(v);\n  }\n\n  clear(): void {\n    this.kv.clear();\n  }\n\n  getIdentifier(value: T) {\n    return this.kv.getByValue(value);\n  }\n\n  getValue(identifier: string) {\n    return this.kv.getByKey(identifier);\n  }\n}\n","import { Registry } from './registry';\nimport { Class } from './types';\n\nexport const ClassRegistry = new Registry<Class>(c => c.name);\n","import { Registry } from './registry';\n\nexport const SymbolRegistry = new Registry<Symbol>(s => s.description ?? '');\n","import {\n  isBigint,\n  isDate,\n  isInfinite,\n  isMap,\n  isNaNValue,\n  isRegExp,\n  isSet,\n  isUndefined,\n  isSymbol,\n  isArray,\n} from './is';\nimport { ClassRegistry } from './class-registry';\nimport { SymbolRegistry } from './symbol-registry';\nimport { fromPairs, includes, entries, find } from 'lodash';\n\nexport type PrimitiveTypeAnnotation = 'number' | 'undefined' | 'bigint';\n\ntype LeafTypeAnnotation = PrimitiveTypeAnnotation | 'regexp' | 'Date';\n\ntype ClassTypeAnnotation = ['class', string];\ntype SymbolTypeAnnotation = ['symbol', string];\n\ntype SimpleTypeAnnotation = LeafTypeAnnotation | 'map' | 'set';\n\ntype CompositeTypeAnnotation = ClassTypeAnnotation | SymbolTypeAnnotation;\n\nexport type TypeAnnotation = SimpleTypeAnnotation | CompositeTypeAnnotation;\n\nconst ALL_PRIMITIVE_TYPE_ANNOTATIONS: TypeAnnotation[] = [\n  'undefined',\n  'number',\n  'bigint',\n];\n\nexport const isPrimitiveTypeAnnotation = (\n  value: any\n): value is PrimitiveTypeAnnotation => {\n  return includes(ALL_PRIMITIVE_TYPE_ANNOTATIONS, value);\n};\n\nconst ALL_TYPE_ANNOTATIONS: TypeAnnotation[] = ALL_PRIMITIVE_TYPE_ANNOTATIONS.concat(\n  ['map', 'regexp', 'set', 'Date']\n);\n\nexport const isTypeAnnotation = (value: any): value is TypeAnnotation => {\n  if (Array.isArray(value)) {\n    return typeof value[1] === 'string';\n  }\n\n  return includes(ALL_TYPE_ANNOTATIONS, value);\n};\n\nfunction simpleTransformation<I, O, A extends SimpleTypeAnnotation>(\n  isApplicable: (v: any) => v is I,\n  annotation: A,\n  transform: (v: I) => O,\n  untransform: (v: O) => I\n) {\n  return {\n    isApplicable,\n    annotation,\n    transform,\n    untransform,\n  };\n}\n\nconst simpleRules = [\n  simpleTransformation(\n    isUndefined,\n    'undefined',\n    () => null,\n    () => undefined\n  ),\n  simpleTransformation(\n    isBigint,\n    'bigint',\n    v => v.toString(),\n    v => {\n      if (typeof BigInt !== 'undefined') {\n        return BigInt(v);\n      }\n\n      console.error('Please add a BigInt polyfill.');\n\n      return v as any;\n    }\n  ),\n  simpleTransformation(\n    isDate,\n    'Date',\n    v => v.toISOString(),\n    v => new Date(v)\n  ),\n\n  simpleTransformation(\n    isRegExp,\n    'regexp',\n    v => '' + v,\n    regex => {\n      const body = regex.slice(1, regex.lastIndexOf('/'));\n      const flags = regex.slice(regex.lastIndexOf('/') + 1);\n      return new RegExp(body, flags);\n    }\n  ),\n\n  simpleTransformation(\n    isSet,\n    'set',\n    v => entries(v).map(([value]) => value),\n    v => new Set(v)\n  ),\n  simpleTransformation(\n    isMap,\n    'map',\n    v => entries(v),\n    v => new Map(v)\n  ),\n\n  simpleTransformation<number, 'NaN' | 'Infinity' | '-Infinity', 'number'>(\n    (v): v is number => isNaNValue(v) || isInfinite(v),\n    'number',\n    v => {\n      if (isNaNValue(v)) {\n        return 'NaN';\n      }\n\n      if (v > 0) {\n        return 'Infinity';\n      } else {\n        return '-Infinity';\n      }\n    },\n    Number\n  ),\n];\n\nfunction compositeTransformation<I, O, A extends CompositeTypeAnnotation>(\n  isApplicable: (v: any) => v is I,\n  annotation: (v: I) => A,\n  transform: (v: I) => O,\n  untransform: (v: O, a: A) => I\n) {\n  return {\n    isApplicable,\n    annotation,\n    transform,\n    untransform,\n  };\n}\n\nconst symbolRule = compositeTransformation(\n  (s): s is Symbol => {\n    if (isSymbol(s)) {\n      const isRegistered = !!SymbolRegistry.getIdentifier(s);\n      return isRegistered;\n    }\n    return false;\n  },\n  s => {\n    const identifier = SymbolRegistry.getIdentifier(s);\n    return ['symbol', identifier!];\n  },\n  v => v.description,\n  (_, a) => {\n    const value = SymbolRegistry.getValue(a[1]);\n    if (!value) {\n      throw new Error('Trying to deserialize unknown symbol');\n    }\n    return value;\n  }\n);\n\nconst classRule = compositeTransformation(\n  (potentialClass): potentialClass is any => {\n    if (potentialClass?.constructor) {\n      const isRegistered = !!ClassRegistry.getIdentifier(\n        potentialClass.constructor\n      );\n      return isRegistered;\n    }\n    return false;\n  },\n  clazz => {\n    const identifier = ClassRegistry.getIdentifier(clazz.constructor);\n    return ['class', identifier!];\n  },\n  v => v,\n  (v, a) => {\n    const clazz = ClassRegistry.getValue(a[1]);\n\n    if (!clazz) {\n      throw new Error('Trying to deserialize unknown class');\n    }\n\n    return Object.assign(Object.create(clazz.prototype), v);\n  }\n);\n\nconst compositeRules = [classRule, symbolRule];\n\nexport const transformValue = (\n  value: any\n): { value: any; type: TypeAnnotation } | undefined => {\n  const applicableSimpleRule = find(simpleRules, rule =>\n    rule.isApplicable(value)\n  );\n\n  if (applicableSimpleRule) {\n    return {\n      value: applicableSimpleRule.transform(value as never),\n      type: applicableSimpleRule.annotation,\n    };\n  }\n\n  const applicableCompositeRule = find(compositeRules, rule =>\n    rule.isApplicable(value)\n  );\n  if (applicableCompositeRule) {\n    return {\n      value: applicableCompositeRule.transform(value as never),\n      type: applicableCompositeRule.annotation(value),\n    };\n  }\n\n  return undefined;\n};\n\nconst simpleRulesByAnnotation = fromPairs(\n  simpleRules.map(r => [r.annotation, r])\n);\n\nexport const untransformValue = (json: any, type: TypeAnnotation) => {\n  if (isArray(type)) {\n    switch (type[0]) {\n      case 'symbol':\n        return symbolRule.untransform(json, type);\n      case 'class':\n        return classRule.untransform(json, type);\n      default:\n        throw new Error('Unknown transformation: ' + type);\n    }\n  } else {\n    const transformation = simpleRulesByAnnotation[type];\n    if (!transformation) {\n      throw new Error('Unknown transformation: ' + type);\n    }\n\n    return transformation.untransform(json as never);\n  }\n};\n","export type StringifiedPath = string;\ntype Path = string[];\n\nexport const escapeKey = (key: string) => key.replace(/\\./g, '\\\\.');\n\nexport const stringifyPath = (path: Path): StringifiedPath =>\n  path\n    .map(String)\n    .map(escapeKey)\n    .join('.');\n\nexport const parsePath = (string: StringifiedPath) => {\n  const result: string[] = [];\n\n  let segment = '';\n  for (let i = 0; i < string.length; i++) {\n    let char = string.charAt(i);\n\n    const isEscapedDot = char === '\\\\' && string.charAt(i + 1) === '.';\n    if (isEscapedDot) {\n      segment += '.';\n      i++;\n      continue;\n    }\n\n    const isEndOfSegment = char === '.';\n    if (isEndOfSegment) {\n      result.push(segment);\n      segment = '';\n      continue;\n    }\n\n    segment += char;\n  }\n\n  const lastSegment = segment;\n  result.push(lastSegment);\n\n  return result;\n};\n\nexport const isStringifiedPath = (\n  string: string\n): string is StringifiedPath => {\n  try {\n    parsePath(string);\n    return true;\n  } catch (anyError) {\n    return false;\n  }\n};\n","import { stringifyPath, parsePath } from './pathstringifier';\nimport { isUndefined, isNull, isArray, isPlainObject } from './is';\nimport { forEach, every, find } from 'lodash';\n\nexport type Tree<T> = InnerNode<T> | Leaf<T>;\ntype Leaf<T> = [T];\ntype InnerNode<T> = [T, Record<string, Tree<T>>];\n\nexport function isTree<T>(\n  v: any,\n  valueChecker: (nodeValue: T) => boolean\n): v is Tree<T> {\n  if (!isArray(v)) {\n    return false;\n  }\n\n  if (v.length === 1) {\n    return valueChecker(v[0]);\n  } else if (v.length === 2) {\n    return valueChecker(v[0]) && every(v[1], v => isTree(v, valueChecker));\n  }\n\n  return false;\n}\n\nfunction isPrefixOf<T>(potentialPrefix: T[], of: T[]): boolean {\n  if (potentialPrefix.length > of.length) {\n    return false;\n  }\n\n  return potentialPrefix.every((value, index) => value === of[index]);\n}\n\nexport module PathTree {\n  export function create<T>(value: T): Tree<T> {\n    return [value];\n  }\n\n  export function get<T>(\n    tree: Tree<T>,\n    path: string[]\n  ): [T, true] | [null, false] {\n    if (path.length === 0) {\n      return [tree[0] as T, true];\n    }\n\n    if (tree.length === 1) {\n      return [null, false];\n    } else {\n      const [head, ...tail] = path;\n      const [, children] = tree;\n      return get(children[head], tail);\n    }\n  }\n\n  /**\n   * @description Optimised for adding new leaves. Does not support adding inner nodes.\n   */\n  export function append<T>(tree: Tree<T>, path: string[], value: T): Tree<T> {\n    if (path.length === 0) {\n      if (tree.length === 1) {\n        return [value];\n      } else {\n        const [, children] = tree;\n        return [value, children];\n      }\n    }\n\n    if (tree.length === 1) {\n      const [nodeValue] = tree;\n      return [nodeValue, { [stringifyPath(path)]: [value] }];\n    } else {\n      const [nodeValue, children] = tree;\n      const availablePaths = Object.keys(children);\n\n      // due to the constraints mentioned in the functions description,\n      // there may be prefixes of `path` already set, but no extensions of it.\n      // If there's such a prefix, we'll find it.\n      const prefix = find(availablePaths, candidate =>\n        isPrefixOf(parsePath(candidate), path)\n      );\n\n      if (isUndefined(prefix)) {\n        return [nodeValue, { ...children, [stringifyPath(path)]: [value] }];\n      } else {\n        const pathWithoutPrefix = path.slice(parsePath(prefix).length);\n        return [\n          nodeValue,\n          {\n            ...children,\n            [prefix]: append(children[prefix], pathWithoutPrefix, value),\n          },\n        ];\n      }\n    }\n  }\n\n  export function appendPath(\n    tree: Tree<string | null>,\n    path: string[]\n  ): Tree<string | null> {\n    const front = path.slice(0, path.length - 1);\n    const last = path[path.length - 1];\n    return append(tree, front, last);\n  }\n\n  /**\n   * Depth-first post-order traversal.\n   */\n  export function traverse<T>(\n    tree: Tree<T>,\n    walker: (v: T, path: string[]) => void,\n    origin: string[] = []\n  ): void {\n    if (tree.length === 1) {\n      const [nodeValue] = tree;\n      walker(nodeValue, origin);\n    } else {\n      const [nodeValue, children] = tree;\n\n      forEach(children, (child, key) => {\n        traverse(child, walker, [...origin, ...parsePath(key)]);\n      });\n\n      walker(nodeValue, origin);\n    }\n  }\n\n  export function traverseWhileIgnoringNullRoot<T>(\n    tree: Tree<T | null>,\n    walker: (v: T, path: string[]) => void\n  ): void {\n    traverse(tree, (v, path) => {\n      if (isNull(v)) {\n        if (path.length === 0) {\n          return;\n        }\n\n        throw new Error('Illegal State');\n      }\n\n      walker(v, path);\n    });\n  }\n\n  export function traversePaths(\n    tree: Tree<string | null>,\n    walker: (path: string[]) => void\n  ) {\n    traverseWhileIgnoringNullRoot(tree, (last, front) =>\n      walker([...front, last])\n    );\n  }\n\n  export type CollapsedRootTree<T> =\n    | Tree<T>\n    | Record<string, Tree<T>>\n    | undefined;\n\n  export function isMinimizedTree<T>(\n    v: any,\n    valueChecker: (v: T) => boolean\n  ): v is CollapsedRootTree<T> {\n    if (isUndefined(v)) {\n      return true;\n    }\n\n    if (isPlainObject(v)) {\n      return every(v, v => isTree(v, valueChecker));\n    }\n\n    return isTree(v, valueChecker);\n  }\n\n  /**\n   * @description Minimizes trees that start with a `null`-root\n   */\n  export function collapseRoot<T>(tree: Tree<T | null>): CollapsedRootTree<T> {\n    if (isNull(tree[0])) {\n      if (tree.length === 1) {\n        return undefined;\n      } else {\n        return tree[1] as Record<string, Tree<T>>;\n      }\n    }\n\n    return tree as Tree<T>;\n  }\n\n  export function expandRoot<T>(tree: CollapsedRootTree<T>): Tree<T | null> {\n    if (isArray(tree)) {\n      return tree;\n    }\n\n    if (isUndefined(tree)) {\n      return [null];\n    }\n\n    return [null, tree];\n  }\n}\n","import { getDeep, setDeep } from './accessDeep';\nimport { isPrimitive, isString } from './is';\nimport { Walker } from './plainer';\nimport {\n  TypeAnnotation,\n  isTypeAnnotation,\n  transformValue,\n  untransformValue,\n} from './transformer';\nimport { PathTree } from './pathtree';\n\nexport interface Annotations {\n  values?: PathTree.CollapsedRootTree<TypeAnnotation>;\n  referentialEqualities?: PathTree.CollapsedRootTree<\n    PathTree.CollapsedRootTree<string>\n  >;\n}\n\nexport function isAnnotations(object: any): object is Annotations {\n  try {\n    if (object.values) {\n      if (!PathTree.isMinimizedTree(object.values, isTypeAnnotation)) {\n        return false;\n      }\n    }\n\n    if (object.referentialEqualities) {\n      if (\n        !PathTree.isMinimizedTree(object.referentialEqualities, tree =>\n          PathTree.isMinimizedTree(tree, isString)\n        )\n      ) {\n        return false;\n      }\n    }\n\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\nclass ValueAnnotationFactory {\n  private tree = PathTree.create<TypeAnnotation | null>(null);\n\n  add(path: any[], annotation: TypeAnnotation) {\n    this.tree = PathTree.append(this.tree, path.map(String), annotation);\n  }\n\n  create() {\n    return PathTree.collapseRoot(this.tree);\n  }\n}\n\nclass ReferentialEqualityAnnotationFactory {\n  private readonly objectIdentities = new Map<any, any[][]>();\n\n  register(object: any, path: any[]) {\n    const paths = this.objectIdentities.get(object) ?? [];\n    paths.push(path);\n    this.objectIdentities.set(object, paths);\n  }\n\n  create() {\n    let tree = PathTree.create<PathTree.CollapsedRootTree<string> | null>(null);\n\n    this.objectIdentities.forEach(paths => {\n      if (paths.length <= 1) {\n        return;\n      }\n\n      const [shortestPath, ...identicalPaths] = paths\n        .map(path => path.map(String))\n        .sort((a, b) => a.length - b.length);\n\n      let identities = PathTree.create<string | null>(null);\n      identicalPaths.forEach(identicalPath => {\n        identities = PathTree.appendPath(identities, identicalPath);\n      });\n\n      const minimizedIdentities = PathTree.collapseRoot(identities);\n      if (!minimizedIdentities) {\n        throw new Error('Illegal State');\n      }\n\n      tree = PathTree.append(tree, shortestPath, minimizedIdentities);\n    });\n\n    return PathTree.collapseRoot(tree);\n  }\n}\n\nclass AnnotationFactory {\n  public readonly valueAnnotations = new ValueAnnotationFactory();\n  public readonly objectIdentities = new ReferentialEqualityAnnotationFactory();\n\n  create(): Annotations {\n    const annotations: Annotations = {};\n\n    const values = this.valueAnnotations.create();\n    if (values) {\n      annotations.values = values;\n    }\n\n    const referentialEqualities = this.objectIdentities.create();\n    if (referentialEqualities) {\n      annotations.referentialEqualities = referentialEqualities;\n    }\n\n    return annotations;\n  }\n}\n\nexport const makeAnnotator = () => {\n  const annotationFactory = new AnnotationFactory();\n  const { valueAnnotations, objectIdentities } = annotationFactory;\n\n  const annotator: Walker = ({ path, node }) => {\n    if (!isPrimitive(node)) {\n      objectIdentities.register(node, path);\n    }\n\n    const transformed = transformValue(node);\n\n    if (transformed) {\n      valueAnnotations.add(path, transformed.type);\n      return transformed.value;\n    } else {\n      return node;\n    }\n  };\n\n  return { getAnnotations: () => annotationFactory.create(), annotator };\n};\n\nexport const applyAnnotations = (plain: any, annotations: Annotations): any => {\n  if (annotations.values) {\n    PathTree.traverseWhileIgnoringNullRoot(\n      PathTree.expandRoot(annotations.values),\n      (type, path) => {\n        plain = setDeep(plain, path, v => untransformValue(v, type));\n      }\n    );\n  }\n\n  if (annotations.referentialEqualities) {\n    PathTree.traverseWhileIgnoringNullRoot(\n      PathTree.expandRoot(annotations.referentialEqualities),\n      (identicalObjects, path) => {\n        const object = getDeep(plain, path);\n\n        PathTree.traversePaths(\n          PathTree.expandRoot(identicalObjects),\n          identicalObjectPath => {\n            plain = setDeep(plain, identicalObjectPath, () => object);\n          }\n        );\n      }\n    );\n  }\n\n  return plain;\n};\n","import { isArray, isMap, isPlainObject, isPrimitive, isSet } from './is';\nimport { mapValues, values, includes, entries } from 'lodash';\n\ninterface WalkerValue {\n  isLeaf: boolean;\n  path: any[];\n  node: any;\n}\n\nexport type Walker = (v: WalkerValue) => any;\n\nconst isDeep = (object: any): boolean =>\n  isPlainObject(object) || isArray(object) || isMap(object) || isSet(object);\n\nexport const plainer = (\n  object: any,\n  walker: Walker,\n  path: any[] = [],\n  alreadySeenObjects: any[] = []\n): any => {\n  if (!isDeep(object)) {\n    return walker({ isLeaf: true, node: object, path });\n  }\n\n  walker({ isLeaf: false, path, node: object });\n\n  if (includes(alreadySeenObjects, object)) {\n    return null;\n  }\n\n  if (!isPrimitive(object)) {\n    alreadySeenObjects = [...alreadySeenObjects, object];\n  }\n\n  if (isArray(object)) {\n    return values(object).map((value, index) =>\n      plainer(value, walker, [...path, index], alreadySeenObjects)\n    );\n  }\n\n  if (isSet(object)) {\n    return entries(object).map(([value], index) =>\n      plainer(value, walker, [...path, index], alreadySeenObjects)\n    );\n  }\n\n  if (isMap(object)) {\n    return entries(object).map(([key, value], index) => [\n      plainer(key, walker, [...path, index, 0], alreadySeenObjects),\n      plainer(value, walker, [...path, index, 1], alreadySeenObjects),\n    ]);\n  }\n\n  if (isPlainObject(object)) {\n    return mapValues(object, (value, key) =>\n      plainer(value, walker, [...path, key], alreadySeenObjects)\n    );\n  }\n};\n","import { Annotations, isAnnotations } from './annotator';\nimport { isUndefined } from './is';\n\nexport type Class = { new (...args: any[]): any };\n\nexport type PrimitveJSONValue = string | number | boolean | undefined | null;\n\nexport type JSONValue = PrimitveJSONValue | JSONArray | JSONObject;\n\nexport interface JSONArray extends Array<JSONValue> {}\n\nexport interface JSONObject {\n  [key: string]: JSONValue;\n}\n\ntype ClassInstance = any;\n\nexport type SerializableJSONValue =\n  | Symbol\n  | Set<SuperJSONValue>\n  | Map<SuperJSONValue, SuperJSONValue>\n  | undefined\n  | bigint\n  | Date\n  | ClassInstance\n  | RegExp;\n\nexport type SuperJSONValue =\n  | JSONValue\n  | SerializableJSONValue\n  | SuperJSONArray\n  | SuperJSONObject;\n\nexport interface SuperJSONArray extends Array<SuperJSONValue> {}\n\nexport interface SuperJSONObject {\n  [key: string]: SuperJSONValue;\n}\n\nexport interface SuperJSONResult {\n  json: JSONValue;\n  meta?: Annotations;\n}\n\nexport function isSuperJSONResult(object: any): object is SuperJSONResult {\n  if (!('json' in object)) {\n    return false;\n  }\n\n  if (isUndefined(object.meta)) {\n    return true;\n  }\n\n  return isAnnotations(object.meta);\n}\n","import { applyAnnotations, makeAnnotator } from './annotator';\nimport { isEmptyObject } from './is';\nimport { plainer } from './plainer';\nimport {\n  SuperJSONResult,\n  SuperJSONValue,\n  isSuperJSONResult,\n  Class,\n} from './types';\nimport { ClassRegistry } from './class-registry';\nimport { SymbolRegistry } from './symbol-registry';\n\nexport const serialize = (object: SuperJSONValue): SuperJSONResult => {\n  const { getAnnotations, annotator } = makeAnnotator();\n  const output = plainer(object, annotator);\n\n  const annotations = getAnnotations();\n\n  return {\n    json: output,\n    meta: isEmptyObject(annotations) ? undefined : annotations,\n  };\n};\n\nexport const deserialize = <T = unknown>(payload: SuperJSONResult): T => {\n  if (!isSuperJSONResult(payload)) {\n    throw new Error('Not a valid SuperJSON payload.');\n  }\n\n  const { json, meta } = payload;\n\n  const result: T = json as any;\n\n  if (!!meta) {\n    return applyAnnotations(result, meta);\n  }\n\n  return result;\n};\n\nconst stringify = (object: SuperJSONValue): string =>\n  JSON.stringify(serialize(object));\n\nexport const parse = <T = unknown>(string: string): T =>\n  deserialize(JSON.parse(string));\n\nconst registerClass = (v: Class, identifier?: string) =>\n  ClassRegistry.register(v, identifier);\nconst unregisterClass = (v: Class) => ClassRegistry.unregister(v);\n\nconst registerSymbol = (v: Symbol, identifier?: string) =>\n  SymbolRegistry.register(v, identifier);\nconst unregisterSymbol = (v: Symbol) => SymbolRegistry.unregister(v);\n\nexport default {\n  stringify,\n  parse,\n  serialize,\n  deserialize,\n  registerClass,\n  unregisterClass,\n  registerSymbol,\n  unregisterSymbol,\n};\n"],"names":["getType","payload","Object","prototype","toString","call","slice","isUndefined","isNull","isPlainObject","constructor","getPrototypeOf","isEmptyObject","keys","length","isArray","isString","isNumber","isNaN","isBoolean","isRegExp","isMap","isSet","isSymbol","isDate","isNaNValue","isPrimitive","isBigint","isInfinite","Infinity","getNthKey","value","n","next","getDeep","object","path","forEach","key","setDeep","mapper","parent","i","index","row","isEnd","type","keyOfRow","get","lastKey","oldValue","newValue","add","keyToRow","newKey","set","DoubleIndexedKV","Map","keyToValue","valueToKey","deleteByValue","otherValue","otherKey","getByKey","getByValue","clear","Registry","generateIdentifier","register","identifier","kv","Error","unregister","v","getIdentifier","getValue","ClassRegistry","c","name","SymbolRegistry","s","description","ALL_PRIMITIVE_TYPE_ANNOTATIONS","ALL_TYPE_ANNOTATIONS","concat","isTypeAnnotation","Array","includes","simpleTransformation","isApplicable","annotation","transform","untransform","simpleRules","undefined","BigInt","console","error","toISOString","Date","regex","body","lastIndexOf","flags","RegExp","entries","map","Set","Number","compositeTransformation","symbolRule","isRegistered","_","a","classRule","potentialClass","clazz","assign","create","compositeRules","transformValue","applicableSimpleRule","find","rule","applicableCompositeRule","simpleRulesByAnnotation","fromPairs","r","untransformValue","json","transformation","escapeKey","replace","stringifyPath","String","join","parsePath","string","result","segment","char","charAt","isEscapedDot","isEndOfSegment","push","lastSegment","isTree","valueChecker","every","isPrefixOf","potentialPrefix","of","PathTree","tree","head","tail","children","append","nodeValue","availablePaths","prefix","candidate","pathWithoutPrefix","appendPath","front","last","traverse","walker","origin","child","traverseWhileIgnoringNullRoot","traversePaths","isMinimizedTree","collapseRoot","expandRoot","isAnnotations","values","referentialEqualities","ValueAnnotationFactory","ReferentialEqualityAnnotationFactory","paths","objectIdentities","sort","b","shortestPath","identicalPaths","identities","identicalPath","minimizedIdentities","AnnotationFactory","annotations","valueAnnotations","makeAnnotator","annotationFactory","annotator","node","transformed","getAnnotations","applyAnnotations","plain","identicalObjects","identicalObjectPath","isDeep","plainer","alreadySeenObjects","isLeaf","mapValues","isSuperJSONResult","meta","serialize","output","deserialize","stringify","JSON","parse","registerClass","unregisterClass","registerSymbol","unregisterSymbol"],"mappings":"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"}