{"version":3,"file":"superjson.cjs.production.min.js","sources":["../src/is.ts","../src/accessDeep.ts","../src/double-indexed-kv.ts","../src/registry.ts","../src/class-registry.ts","../src/symbol-registry.ts","../src/transformer.ts","../src/pathstringifier.ts","../src/pathtree.ts","../src/annotator.ts","../src/index.ts","../src/plainer.ts","../src/types.ts"],"sourcesContent":["const getType = (payload: any): string =>\n  Object.prototype.toString.call(payload).slice(8, -1);\n\nexport const isUndefined = (payload: any): payload is undefined =>\n  getType(payload) === 'Undefined';\n\nexport const isNull = (payload: any): payload is null =>\n  getType(payload) === 'Null';\n\nexport const isPlainObject = (\n  payload: any\n): payload is { [key: string]: any } => {\n  if (getType(payload) !== 'Object') return false;\n  return (\n    payload.constructor === Object &&\n    Object.getPrototypeOf(payload) === Object.prototype\n  );\n};\n\nexport const isEmptyObject = (payload: any): payload is {} =>\n  isPlainObject(payload) && Object.keys(payload).length === 0;\n\nexport const isArray = (payload: any): payload is any[] =>\n  getType(payload) === 'Array';\n\nexport const isString = (payload: any): payload is string =>\n  getType(payload) === 'String';\n\nexport const isNumber = (payload: any): payload is number =>\n  getType(payload) === 'Number' && !isNaN(payload);\n\nexport const isBoolean = (payload: any): payload is boolean =>\n  getType(payload) === 'Boolean';\n\nexport const isRegExp = (payload: any): payload is RegExp =>\n  getType(payload) === 'RegExp';\n\nexport const isMap = (payload: any): payload is Map<any, any> =>\n  getType(payload) === 'Map';\n\nexport const isSet = (payload: any): payload is Set<any> =>\n  getType(payload) === 'Set';\n\nexport const isSymbol = (payload: any): payload is symbol =>\n  getType(payload) === 'Symbol';\n\nexport const isDate = (payload: any): payload is Date =>\n  getType(payload) === 'Date' && !isNaN(payload);\n\nexport const isNaNValue = (payload: any): payload is typeof NaN =>\n  getType(payload) === 'Number' && isNaN(payload);\n\nexport const isPrimitive = (\n  payload: any\n): payload is boolean | null | undefined | number | string | symbol =>\n  isBoolean(payload) ||\n  isNull(payload) ||\n  isUndefined(payload) ||\n  isNumber(payload) ||\n  isString(payload) ||\n  isSymbol(payload);\n\nexport const isBigint = (payload: any): payload is bigint =>\n  getType(payload) === 'BigInt';\n\nexport const isInfinite = (payload: any): payload is number =>\n  payload === Infinity || payload === -Infinity;\n","import { isMap, isArray, isPlainObject, isSet } from './is';\n\nexport const getNthKey = (value: Map<any, any> | Set<any>, n: number): any => {\n  const keys = value.keys();\n  while (n > 0) {\n    keys.next();\n    n--;\n  }\n\n  return keys.next().value;\n};\n\nexport const getDeep = (object: object, path: (string | number)[]): object => {\n  path.forEach(key => {\n    object = (object as any)[key];\n  });\n\n  return object;\n};\n\nexport const setDeep = (\n  object: any,\n  path: (string | number)[],\n  mapper: (v: any) => any\n): any => {\n  if (path.length === 0) {\n    return mapper(object);\n  }\n\n  let parent = object;\n\n  for (let i = 0; i < path.length - 1; i++) {\n    const key = path[i];\n\n    if (isArray(parent)) {\n      const index = +key;\n      parent = parent[index];\n    } else if (isPlainObject(parent)) {\n      parent = parent[key];\n    } else if (isSet(parent)) {\n      const row = +key;\n      parent = getNthKey(parent, row);\n    } else if (isMap(parent)) {\n      const isEnd = i === path.length - 2;\n      if (isEnd) {\n        break;\n      }\n\n      const row = +key;\n      const type = +path[i + 1] === 0 ? 'key' : 'value';\n\n      const keyOfRow = getNthKey(parent, row);\n      switch (type) {\n        case 'key':\n          parent = keyOfRow;\n          break;\n        case 'value':\n          parent = parent.get(keyOfRow);\n          break;\n      }\n\n      i++;\n    }\n  }\n\n  const lastKey = path[path.length - 1];\n\n  if (isArray(parent) || isPlainObject(parent)) {\n    parent[lastKey] = mapper(parent[lastKey]);\n  }\n\n  if (isSet(parent)) {\n    const oldValue = getNthKey(parent, +lastKey);\n    const newValue = mapper(oldValue);\n    if (oldValue !== newValue) {\n      parent.delete(oldValue);\n      parent.add(newValue);\n    }\n  }\n\n  if (isMap(parent)) {\n    const row = +path[path.length - 2];\n    const keyToRow = getNthKey(parent, row);\n\n    const type = +lastKey === 0 ? 'key' : 'value';\n    switch (type) {\n      case 'key': {\n        const newKey = mapper(keyToRow);\n        parent.set(newKey, parent.get(keyToRow));\n\n        if (newKey !== keyToRow) {\n          parent.delete(keyToRow);\n        }\n        break;\n      }\n\n      case 'value': {\n        parent.set(keyToRow, mapper(parent.get(keyToRow)));\n        break;\n      }\n    }\n  }\n\n  return object;\n};\n","export class DoubleIndexedKV<K, V> {\n  keyToValue = new Map<K, V>();\n  valueToKey = new Map<V, K>();\n\n  set(key: K, value: V) {\n    this.keyToValue.set(key, value);\n    this.valueToKey.set(value, key);\n  }\n\n  deleteByValue(value: V) {\n    this.valueToKey.delete(value);\n    this.keyToValue.forEach((otherValue, otherKey) => {\n      if (value === otherValue) {\n        this.keyToValue.delete(otherKey);\n      }\n    });\n  }\n\n  getByKey(key: K): V | undefined {\n    return this.keyToValue.get(key);\n  }\n\n  getByValue(value: V): K | undefined {\n    return this.valueToKey.get(value);\n  }\n\n  clear() {\n    this.keyToValue.clear();\n    this.valueToKey.clear();\n  }\n}\n","import { DoubleIndexedKV } from './double-indexed-kv';\n\nexport class Registry<T> {\n  private kv = new DoubleIndexedKV<string, T>();\n\n  constructor(private readonly generateIdentifier: (v: T) => string) {}\n\n  register(value: T, identifier?: string): void {\n    if (this.kv.getByValue(value)) {\n      return;\n    }\n\n    if (!identifier) {\n      identifier = this.generateIdentifier(value);\n    }\n\n    if (this.kv.getByKey(identifier)) {\n      throw new Error('Ambiguous class, provide a unique identifier.');\n    }\n\n    this.kv.set(identifier, value);\n  }\n\n  unregister(v: T): void {\n    this.kv.deleteByValue(v);\n  }\n\n  clear(): void {\n    this.kv.clear();\n  }\n\n  getIdentifier(value: T) {\n    return this.kv.getByValue(value);\n  }\n\n  getValue(identifier: string) {\n    return this.kv.getByKey(identifier);\n  }\n}\n","import { Registry } from './registry';\nimport { Class } from './types';\n\nexport const ClassRegistry = new Registry<Class>(c => c.name);\n","import { Registry } from './registry';\n\nexport const SymbolRegistry = new Registry<Symbol>(s => s.description ?? '');\n","import {\n  isBigint,\n  isDate,\n  isInfinite,\n  isMap,\n  isNaNValue,\n  isRegExp,\n  isSet,\n  isUndefined,\n  isSymbol,\n  isArray,\n} from './is';\nimport { ClassRegistry } from './class-registry';\nimport { SymbolRegistry } from './symbol-registry';\nimport { fromPairs, includes, entries, find } from 'lodash';\n\nexport type PrimitiveTypeAnnotation = 'number' | 'undefined' | 'bigint';\n\ntype LeafTypeAnnotation = PrimitiveTypeAnnotation | 'regexp' | 'Date';\n\ntype ClassTypeAnnotation = ['class', string];\ntype SymbolTypeAnnotation = ['symbol', string];\n\ntype SimpleTypeAnnotation = LeafTypeAnnotation | 'map' | 'set';\n\ntype CompositeTypeAnnotation = ClassTypeAnnotation | SymbolTypeAnnotation;\n\nexport type TypeAnnotation = SimpleTypeAnnotation | CompositeTypeAnnotation;\n\nconst ALL_PRIMITIVE_TYPE_ANNOTATIONS: TypeAnnotation[] = [\n  'undefined',\n  'number',\n  'bigint',\n];\n\nexport const isPrimitiveTypeAnnotation = (\n  value: any\n): value is PrimitiveTypeAnnotation => {\n  return includes(ALL_PRIMITIVE_TYPE_ANNOTATIONS, value);\n};\n\nconst ALL_TYPE_ANNOTATIONS: TypeAnnotation[] = ALL_PRIMITIVE_TYPE_ANNOTATIONS.concat(\n  ['map', 'regexp', 'set', 'Date']\n);\n\nexport const isTypeAnnotation = (value: any): value is TypeAnnotation => {\n  if (Array.isArray(value)) {\n    return typeof value[1] === 'string';\n  }\n\n  return includes(ALL_TYPE_ANNOTATIONS, value);\n};\n\nfunction simpleTransformation<I, O, A extends SimpleTypeAnnotation>(\n  isApplicable: (v: any) => v is I,\n  annotation: A,\n  transform: (v: I) => O,\n  untransform: (v: O) => I\n) {\n  return {\n    isApplicable,\n    annotation,\n    transform,\n    untransform,\n  };\n}\n\nconst simpleRules = [\n  simpleTransformation(\n    isUndefined,\n    'undefined',\n    () => null,\n    () => undefined\n  ),\n  simpleTransformation(\n    isBigint,\n    'bigint',\n    v => v.toString(),\n    v => {\n      if (typeof BigInt !== 'undefined') {\n        return BigInt(v);\n      }\n\n      console.error('Please add a BigInt polyfill.');\n\n      return v as any;\n    }\n  ),\n  simpleTransformation(\n    isDate,\n    'Date',\n    v => v.toISOString(),\n    v => new Date(v)\n  ),\n\n  simpleTransformation(\n    isRegExp,\n    'regexp',\n    v => '' + v,\n    regex => {\n      const body = regex.slice(1, regex.lastIndexOf('/'));\n      const flags = regex.slice(regex.lastIndexOf('/') + 1);\n      return new RegExp(body, flags);\n    }\n  ),\n\n  simpleTransformation(\n    isSet,\n    'set',\n    v => entries(v).map(([value]) => value),\n    v => new Set(v)\n  ),\n  simpleTransformation(\n    isMap,\n    'map',\n    v => entries(v),\n    v => new Map(v)\n  ),\n\n  simpleTransformation<number, 'NaN' | 'Infinity' | '-Infinity', 'number'>(\n    (v): v is number => isNaNValue(v) || isInfinite(v),\n    'number',\n    v => {\n      if (isNaNValue(v)) {\n        return 'NaN';\n      }\n\n      if (v > 0) {\n        return 'Infinity';\n      } else {\n        return '-Infinity';\n      }\n    },\n    Number\n  ),\n];\n\nfunction compositeTransformation<I, O, A extends CompositeTypeAnnotation>(\n  isApplicable: (v: any) => v is I,\n  annotation: (v: I) => A,\n  transform: (v: I) => O,\n  untransform: (v: O, a: A) => I\n) {\n  return {\n    isApplicable,\n    annotation,\n    transform,\n    untransform,\n  };\n}\n\nconst symbolRule = compositeTransformation(\n  (s): s is Symbol => {\n    if (isSymbol(s)) {\n      const isRegistered = !!SymbolRegistry.getIdentifier(s);\n      return isRegistered;\n    }\n    return false;\n  },\n  s => {\n    const identifier = SymbolRegistry.getIdentifier(s);\n    return ['symbol', identifier!];\n  },\n  v => v.description,\n  (_, a) => {\n    const value = SymbolRegistry.getValue(a[1]);\n    if (!value) {\n      throw new Error('Trying to deserialize unknown symbol');\n    }\n    return value;\n  }\n);\n\nconst classRule = compositeTransformation(\n  (potentialClass): potentialClass is any => {\n    if (potentialClass?.constructor) {\n      const isRegistered = !!ClassRegistry.getIdentifier(\n        potentialClass.constructor\n      );\n      return isRegistered;\n    }\n    return false;\n  },\n  clazz => {\n    const identifier = ClassRegistry.getIdentifier(clazz.constructor);\n    return ['class', identifier!];\n  },\n  v => v,\n  (v, a) => {\n    const clazz = ClassRegistry.getValue(a[1]);\n\n    if (!clazz) {\n      throw new Error('Trying to deserialize unknown class');\n    }\n\n    return Object.assign(Object.create(clazz.prototype), v);\n  }\n);\n\nconst compositeRules = [classRule, symbolRule];\n\nexport const transformValue = (\n  value: any\n): { value: any; type: TypeAnnotation } | undefined => {\n  const applicableSimpleRule = find(simpleRules, rule =>\n    rule.isApplicable(value)\n  );\n\n  if (applicableSimpleRule) {\n    return {\n      value: applicableSimpleRule.transform(value as never),\n      type: applicableSimpleRule.annotation,\n    };\n  }\n\n  const applicableCompositeRule = find(compositeRules, rule =>\n    rule.isApplicable(value)\n  );\n  if (applicableCompositeRule) {\n    return {\n      value: applicableCompositeRule.transform(value as never),\n      type: applicableCompositeRule.annotation(value),\n    };\n  }\n\n  return undefined;\n};\n\nconst simpleRulesByAnnotation = fromPairs(\n  simpleRules.map(r => [r.annotation, r])\n);\n\nexport const untransformValue = (json: any, type: TypeAnnotation) => {\n  if (isArray(type)) {\n    switch (type[0]) {\n      case 'symbol':\n        return symbolRule.untransform(json, type);\n      case 'class':\n        return classRule.untransform(json, type);\n      default:\n        throw new Error('Unknown transformation: ' + type);\n    }\n  } else {\n    const transformation = simpleRulesByAnnotation[type];\n    if (!transformation) {\n      throw new Error('Unknown transformation: ' + type);\n    }\n\n    return transformation.untransform(json as never);\n  }\n};\n","export type StringifiedPath = string;\ntype Path = string[];\n\nexport const escapeKey = (key: string) => key.replace(/\\./g, '\\\\.');\n\nexport const stringifyPath = (path: Path): StringifiedPath =>\n  path\n    .map(String)\n    .map(escapeKey)\n    .join('.');\n\nexport const parsePath = (string: StringifiedPath) => {\n  const result: string[] = [];\n\n  let segment = '';\n  for (let i = 0; i < string.length; i++) {\n    let char = string.charAt(i);\n\n    const isEscapedDot = char === '\\\\' && string.charAt(i + 1) === '.';\n    if (isEscapedDot) {\n      segment += '.';\n      i++;\n      continue;\n    }\n\n    const isEndOfSegment = char === '.';\n    if (isEndOfSegment) {\n      result.push(segment);\n      segment = '';\n      continue;\n    }\n\n    segment += char;\n  }\n\n  const lastSegment = segment;\n  result.push(lastSegment);\n\n  return result;\n};\n\nexport const isStringifiedPath = (\n  string: string\n): string is StringifiedPath => {\n  try {\n    parsePath(string);\n    return true;\n  } catch (anyError) {\n    return false;\n  }\n};\n","import { stringifyPath, parsePath } from './pathstringifier';\nimport { isUndefined, isNull, isArray, isPlainObject } from './is';\nimport { forEach, every, find } from 'lodash';\n\nexport type Tree<T> = InnerNode<T> | Leaf<T>;\ntype Leaf<T> = [T];\ntype InnerNode<T> = [T, Record<string, Tree<T>>];\n\nexport function isTree<T>(\n  v: any,\n  valueChecker: (nodeValue: T) => boolean\n): v is Tree<T> {\n  if (!isArray(v)) {\n    return false;\n  }\n\n  if (v.length === 1) {\n    return valueChecker(v[0]);\n  } else if (v.length === 2) {\n    return valueChecker(v[0]) && every(v[1], v => isTree(v, valueChecker));\n  }\n\n  return false;\n}\n\nfunction isPrefixOf<T>(potentialPrefix: T[], of: T[]): boolean {\n  if (potentialPrefix.length > of.length) {\n    return false;\n  }\n\n  return potentialPrefix.every((value, index) => value === of[index]);\n}\n\nexport module PathTree {\n  export function create<T>(value: T): Tree<T> {\n    return [value];\n  }\n\n  export function get<T>(\n    tree: Tree<T>,\n    path: string[]\n  ): [T, true] | [null, false] {\n    if (path.length === 0) {\n      return [tree[0] as T, true];\n    }\n\n    if (tree.length === 1) {\n      return [null, false];\n    } else {\n      const [head, ...tail] = path;\n      const [, children] = tree;\n      return get(children[head], tail);\n    }\n  }\n\n  /**\n   * @description Optimised for adding new leaves. Does not support adding inner nodes.\n   */\n  export function append<T>(tree: Tree<T>, path: string[], value: T): Tree<T> {\n    if (path.length === 0) {\n      if (tree.length === 1) {\n        return [value];\n      } else {\n        const [, children] = tree;\n        return [value, children];\n      }\n    }\n\n    if (tree.length === 1) {\n      const [nodeValue] = tree;\n      return [nodeValue, { [stringifyPath(path)]: [value] }];\n    } else {\n      const [nodeValue, children] = tree;\n      const availablePaths = Object.keys(children);\n\n      // due to the constraints mentioned in the functions description,\n      // there may be prefixes of `path` already set, but no extensions of it.\n      // If there's such a prefix, we'll find it.\n      const prefix = find(availablePaths, candidate =>\n        isPrefixOf(parsePath(candidate), path)\n      );\n\n      if (isUndefined(prefix)) {\n        return [nodeValue, { ...children, [stringifyPath(path)]: [value] }];\n      } else {\n        const pathWithoutPrefix = path.slice(parsePath(prefix).length);\n        return [\n          nodeValue,\n          {\n            ...children,\n            [prefix]: append(children[prefix], pathWithoutPrefix, value),\n          },\n        ];\n      }\n    }\n  }\n\n  export function appendPath(\n    tree: Tree<string | null>,\n    path: string[]\n  ): Tree<string | null> {\n    const front = path.slice(0, path.length - 1);\n    const last = path[path.length - 1];\n    return append(tree, front, last);\n  }\n\n  /**\n   * Depth-first post-order traversal.\n   */\n  export function traverse<T>(\n    tree: Tree<T>,\n    walker: (v: T, path: string[]) => void,\n    origin: string[] = []\n  ): void {\n    if (tree.length === 1) {\n      const [nodeValue] = tree;\n      walker(nodeValue, origin);\n    } else {\n      const [nodeValue, children] = tree;\n\n      forEach(children, (child, key) => {\n        traverse(child, walker, [...origin, ...parsePath(key)]);\n      });\n\n      walker(nodeValue, origin);\n    }\n  }\n\n  export function traverseWhileIgnoringNullRoot<T>(\n    tree: Tree<T | null>,\n    walker: (v: T, path: string[]) => void\n  ): void {\n    traverse(tree, (v, path) => {\n      if (isNull(v)) {\n        if (path.length === 0) {\n          return;\n        }\n\n        throw new Error('Illegal State');\n      }\n\n      walker(v, path);\n    });\n  }\n\n  export function traversePaths(\n    tree: Tree<string | null>,\n    walker: (path: string[]) => void\n  ) {\n    traverseWhileIgnoringNullRoot(tree, (last, front) =>\n      walker([...front, last])\n    );\n  }\n\n  export type CollapsedRootTree<T> =\n    | Tree<T>\n    | Record<string, Tree<T>>\n    | undefined;\n\n  export function isMinimizedTree<T>(\n    v: any,\n    valueChecker: (v: T) => boolean\n  ): v is CollapsedRootTree<T> {\n    if (isUndefined(v)) {\n      return true;\n    }\n\n    if (isPlainObject(v)) {\n      return every(v, v => isTree(v, valueChecker));\n    }\n\n    return isTree(v, valueChecker);\n  }\n\n  /**\n   * @description Minimizes trees that start with a `null`-root\n   */\n  export function collapseRoot<T>(tree: Tree<T | null>): CollapsedRootTree<T> {\n    if (isNull(tree[0])) {\n      if (tree.length === 1) {\n        return undefined;\n      } else {\n        return tree[1] as Record<string, Tree<T>>;\n      }\n    }\n\n    return tree as Tree<T>;\n  }\n\n  export function expandRoot<T>(tree: CollapsedRootTree<T>): Tree<T | null> {\n    if (isArray(tree)) {\n      return tree;\n    }\n\n    if (isUndefined(tree)) {\n      return [null];\n    }\n\n    return [null, tree];\n  }\n}\n","import { getDeep, setDeep } from './accessDeep';\nimport { isPrimitive, isString } from './is';\nimport { Walker } from './plainer';\nimport {\n  TypeAnnotation,\n  isTypeAnnotation,\n  transformValue,\n  untransformValue,\n} from './transformer';\nimport { PathTree } from './pathtree';\n\nexport interface Annotations {\n  values?: PathTree.CollapsedRootTree<TypeAnnotation>;\n  referentialEqualities?: PathTree.CollapsedRootTree<\n    PathTree.CollapsedRootTree<string>\n  >;\n}\n\nexport function isAnnotations(object: any): object is Annotations {\n  try {\n    if (object.values) {\n      if (!PathTree.isMinimizedTree(object.values, isTypeAnnotation)) {\n        return false;\n      }\n    }\n\n    if (object.referentialEqualities) {\n      if (\n        !PathTree.isMinimizedTree(object.referentialEqualities, tree =>\n          PathTree.isMinimizedTree(tree, isString)\n        )\n      ) {\n        return false;\n      }\n    }\n\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\nclass ValueAnnotationFactory {\n  private tree = PathTree.create<TypeAnnotation | null>(null);\n\n  add(path: any[], annotation: TypeAnnotation) {\n    this.tree = PathTree.append(this.tree, path.map(String), annotation);\n  }\n\n  create() {\n    return PathTree.collapseRoot(this.tree);\n  }\n}\n\nclass ReferentialEqualityAnnotationFactory {\n  private readonly objectIdentities = new Map<any, any[][]>();\n\n  register(object: any, path: any[]) {\n    const paths = this.objectIdentities.get(object) ?? [];\n    paths.push(path);\n    this.objectIdentities.set(object, paths);\n  }\n\n  create() {\n    let tree = PathTree.create<PathTree.CollapsedRootTree<string> | null>(null);\n\n    this.objectIdentities.forEach(paths => {\n      if (paths.length <= 1) {\n        return;\n      }\n\n      const [shortestPath, ...identicalPaths] = paths\n        .map(path => path.map(String))\n        .sort((a, b) => a.length - b.length);\n\n      let identities = PathTree.create<string | null>(null);\n      identicalPaths.forEach(identicalPath => {\n        identities = PathTree.appendPath(identities, identicalPath);\n      });\n\n      const minimizedIdentities = PathTree.collapseRoot(identities);\n      if (!minimizedIdentities) {\n        throw new Error('Illegal State');\n      }\n\n      tree = PathTree.append(tree, shortestPath, minimizedIdentities);\n    });\n\n    return PathTree.collapseRoot(tree);\n  }\n}\n\nclass AnnotationFactory {\n  public readonly valueAnnotations = new ValueAnnotationFactory();\n  public readonly objectIdentities = new ReferentialEqualityAnnotationFactory();\n\n  create(): Annotations {\n    const annotations: Annotations = {};\n\n    const values = this.valueAnnotations.create();\n    if (values) {\n      annotations.values = values;\n    }\n\n    const referentialEqualities = this.objectIdentities.create();\n    if (referentialEqualities) {\n      annotations.referentialEqualities = referentialEqualities;\n    }\n\n    return annotations;\n  }\n}\n\nexport const makeAnnotator = () => {\n  const annotationFactory = new AnnotationFactory();\n  const { valueAnnotations, objectIdentities } = annotationFactory;\n\n  const annotator: Walker = ({ path, node }) => {\n    if (!isPrimitive(node)) {\n      objectIdentities.register(node, path);\n    }\n\n    const transformed = transformValue(node);\n\n    if (transformed) {\n      valueAnnotations.add(path, transformed.type);\n      return transformed.value;\n    } else {\n      return node;\n    }\n  };\n\n  return { getAnnotations: () => annotationFactory.create(), annotator };\n};\n\nexport const applyAnnotations = (plain: any, annotations: Annotations): any => {\n  if (annotations.values) {\n    PathTree.traverseWhileIgnoringNullRoot(\n      PathTree.expandRoot(annotations.values),\n      (type, path) => {\n        plain = setDeep(plain, path, v => untransformValue(v, type));\n      }\n    );\n  }\n\n  if (annotations.referentialEqualities) {\n    PathTree.traverseWhileIgnoringNullRoot(\n      PathTree.expandRoot(annotations.referentialEqualities),\n      (identicalObjects, path) => {\n        const object = getDeep(plain, path);\n\n        PathTree.traversePaths(\n          PathTree.expandRoot(identicalObjects),\n          identicalObjectPath => {\n            plain = setDeep(plain, identicalObjectPath, () => object);\n          }\n        );\n      }\n    );\n  }\n\n  return plain;\n};\n","import { applyAnnotations, makeAnnotator } from './annotator';\nimport { isEmptyObject } from './is';\nimport { plainer } from './plainer';\nimport {\n  SuperJSONResult,\n  SuperJSONValue,\n  isSuperJSONResult,\n  Class,\n} from './types';\nimport { ClassRegistry } from './class-registry';\nimport { SymbolRegistry } from './symbol-registry';\n\nexport const serialize = (object: SuperJSONValue): SuperJSONResult => {\n  const { getAnnotations, annotator } = makeAnnotator();\n  const output = plainer(object, annotator);\n\n  const annotations = getAnnotations();\n\n  return {\n    json: output,\n    meta: isEmptyObject(annotations) ? undefined : annotations,\n  };\n};\n\nexport const deserialize = <T = unknown>(payload: SuperJSONResult): T => {\n  if (!isSuperJSONResult(payload)) {\n    throw new Error('Not a valid SuperJSON payload.');\n  }\n\n  const { json, meta } = payload;\n\n  const result: T = json as any;\n\n  if (!!meta) {\n    return applyAnnotations(result, meta);\n  }\n\n  return result;\n};\n\nconst stringify = (object: SuperJSONValue): string =>\n  JSON.stringify(serialize(object));\n\nexport const parse = <T = unknown>(string: string): T =>\n  deserialize(JSON.parse(string));\n\nconst registerClass = (v: Class, identifier?: string) =>\n  ClassRegistry.register(v, identifier);\nconst unregisterClass = (v: Class) => ClassRegistry.unregister(v);\n\nconst registerSymbol = (v: Symbol, identifier?: string) =>\n  SymbolRegistry.register(v, identifier);\nconst unregisterSymbol = (v: Symbol) => SymbolRegistry.unregister(v);\n\nexport default {\n  stringify,\n  parse,\n  serialize,\n  deserialize,\n  registerClass,\n  unregisterClass,\n  registerSymbol,\n  unregisterSymbol,\n};\n","import { isArray, isMap, isPlainObject, isPrimitive, isSet } from './is';\nimport { mapValues, values, includes, entries } from 'lodash';\n\ninterface WalkerValue {\n  isLeaf: boolean;\n  path: any[];\n  node: any;\n}\n\nexport type Walker = (v: WalkerValue) => any;\n\nconst isDeep = (object: any): boolean =>\n  isPlainObject(object) || isArray(object) || isMap(object) || isSet(object);\n\nexport const plainer = (\n  object: any,\n  walker: Walker,\n  path: any[] = [],\n  alreadySeenObjects: any[] = []\n): any => {\n  if (!isDeep(object)) {\n    return walker({ isLeaf: true, node: object, path });\n  }\n\n  walker({ isLeaf: false, path, node: object });\n\n  if (includes(alreadySeenObjects, object)) {\n    return null;\n  }\n\n  if (!isPrimitive(object)) {\n    alreadySeenObjects = [...alreadySeenObjects, object];\n  }\n\n  if (isArray(object)) {\n    return values(object).map((value, index) =>\n      plainer(value, walker, [...path, index], alreadySeenObjects)\n    );\n  }\n\n  if (isSet(object)) {\n    return entries(object).map(([value], index) =>\n      plainer(value, walker, [...path, index], alreadySeenObjects)\n    );\n  }\n\n  if (isMap(object)) {\n    return entries(object).map(([key, value], index) => [\n      plainer(key, walker, [...path, index, 0], alreadySeenObjects),\n      plainer(value, walker, [...path, index, 1], alreadySeenObjects),\n    ]);\n  }\n\n  if (isPlainObject(object)) {\n    return mapValues(object, (value, key) =>\n      plainer(value, walker, [...path, key], alreadySeenObjects)\n    );\n  }\n};\n","import { Annotations, isAnnotations } from './annotator';\nimport { isUndefined } from './is';\n\nexport type Class = { new (...args: any[]): any };\n\nexport type PrimitveJSONValue = string | number | boolean | undefined | null;\n\nexport type JSONValue = PrimitveJSONValue | JSONArray | JSONObject;\n\nexport interface JSONArray extends Array<JSONValue> {}\n\nexport interface JSONObject {\n  [key: string]: JSONValue;\n}\n\ntype ClassInstance = any;\n\nexport type SerializableJSONValue =\n  | Symbol\n  | Set<SuperJSONValue>\n  | Map<SuperJSONValue, SuperJSONValue>\n  | undefined\n  | bigint\n  | Date\n  | ClassInstance\n  | RegExp;\n\nexport type SuperJSONValue =\n  | JSONValue\n  | SerializableJSONValue\n  | SuperJSONArray\n  | SuperJSONObject;\n\nexport interface SuperJSONArray extends Array<SuperJSONValue> {}\n\nexport interface SuperJSONObject {\n  [key: string]: SuperJSONValue;\n}\n\nexport interface SuperJSONResult {\n  json: JSONValue;\n  meta?: Annotations;\n}\n\nexport function isSuperJSONResult(object: any): object is SuperJSONResult {\n  if (!('json' in object)) {\n    return false;\n  }\n\n  if (isUndefined(object.meta)) {\n    return true;\n  }\n\n  return isAnnotations(object.meta);\n}\n"],"names":["getType","payload","Object","prototype","toString","call","slice","isUndefined","isNull","isPlainObject","constructor","getPrototypeOf","isArray","isString","isRegExp","isMap","isSet","isSymbol","isDate","isNaN","isNaNValue","isPrimitive","isBoolean","isNumber","isBigint","getNthKey","value","n","keys","next","setDeep","object","path","mapper","length","parent","i","key","type","keyOfRow","get","lastKey","oldValue","newValue","add","keyToRow","newKey","set","DoubleIndexedKV","Map","keyToValue","valueToKey","deleteByValue","forEach","otherValue","otherKey","_this","getByKey","this","getByValue","clear","Registry","generateIdentifier","register","identifier","kv","Error","unregister","v","getIdentifier","getValue","ClassRegistry","c","name","SymbolRegistry","s","description","ALL_TYPE_ANNOTATIONS","concat","isTypeAnnotation","Array","includes","simpleTransformation","isApplicable","annotation","transform","untransform","simpleRules","BigInt","console","error","toISOString","Date","regex","body","lastIndexOf","flags","RegExp","entries","map","Set","Infinity","Number","compositeTransformation","symbolRule","_","a","classRule","potentialClass","clazz","assign","create","compositeRules","simpleRulesByAnnotation","fromPairs","r","PathTree","escapeKey","replace","stringifyPath","String","join","parsePath","string","result","segment","char","charAt","push","isTree","valueChecker","every","append","tree","nodeValue","children","availablePaths","prefix","find","candidate","potentialPrefix","of","index","pathWithoutPrefix","traverse","walker","origin","child","traverseWhileIgnoringNullRoot","head","tail","last","front","ValueAnnotationFactory","collapseRoot","ReferentialEqualityAnnotationFactory","paths","objectIdentities","sort","b","shortestPath","identicalPaths","identities","identicalPath","appendPath","minimizedIdentities","AnnotationFactory","annotations","values","valueAnnotations","referentialEqualities","serialize","annotationFactory","getAnnotations","annotator","node","transformed","applicableSimpleRule","rule","applicableCompositeRule","transformValue","output","plainer","alreadySeenObjects","isDeep","isLeaf","mapValues","json","meta","undefined","deserialize","isMinimizedTree","isAnnotations","plain","expandRoot","transformation","untransformValue","identicalObjects","getDeep","traversePaths","identicalObjectPath","parse","JSON","stringify","registerClass","unregisterClass","registerSymbol","unregisterSymbol"],"mappings":"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"}