var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
import * as NodeURL from "url";
import path from "path";
function credentialsToUri(credentials) {
  const type = databaseTypeToProtocol(credentials.type);
  if (credentials.type === "mongodb") {
    return credentials.uri;
  } else if (credentials.type === "sqlite") {
    return credentials.uri;
  }
  const url = new NodeURL.URL(type + "//");
  if (credentials.host) {
    url.hostname = credentials.host;
  }
  if (credentials.type === "postgresql") {
    if (credentials.database) {
      url.pathname = "/" + credentials.database;
    }
    if (credentials.schema) {
      url.searchParams.set("schema", credentials.schema);
    }
    if (credentials.socket) {
      url.host = credentials.socket;
    }
  } else if (credentials.type === "mysql") {
    url.pathname = "/" + (credentials.database || credentials.schema || "");
    if (credentials.socket) {
      url.searchParams.set("socket", credentials.socket);
    }
  }
  if (credentials.ssl) {
    url.searchParams.set("sslmode", "prefer");
  }
  if (credentials.user) {
    url.username = credentials.user;
  }
  if (credentials.password) {
    url.password = credentials.password;
  }
  if (credentials.port) {
    url.port = String(credentials.port);
  }
  url.host = `${url.hostname}${url.port ? `:${url.port}` : ""}`;
  if (credentials.extraFields) {
    for (const [key, value] of Object.entries(credentials.extraFields)) {
      url.searchParams.set(key, value);
    }
  }
  if (url.pathname === "/") {
    url.pathname = "";
  }
  return url.toString();
}
__name(credentialsToUri, "credentialsToUri");
function uriToCredentials(connectionString) {
  let uri;
  try {
    uri = new NodeURL.URL(connectionString);
  } catch (e) {
    throw new Error("Invalid data source URL, see https://www.prisma.io/docs/reference/database-reference/connection-urls");
  }
  const type = protocolToConnectorType(uri.protocol);
  if (type === "mongodb") {
    return {
      type,
      uri: connectionString
    };
  }
  const exists = /* @__PURE__ */ __name((str) => str && str.length > 0, "exists");
  const extraFields = {};
  const schema = uri.searchParams.get("schema");
  const socket = uri.searchParams.get("socket");
  for (const [name, value] of uri.searchParams) {
    if (!["schema", "socket"].includes(name)) {
      extraFields[name] = value;
    }
  }
  let database = void 0;
  let defaultSchema = void 0;
  if (type === "sqlite" && uri.pathname) {
    if (uri.pathname.startsWith("file:")) {
      database = uri.pathname.slice(5);
    }
    if (uri.pathname.startsWith("sqlite:")) {
      database = uri.pathname.slice(7);
    } else {
      database = path.basename(uri.pathname);
    }
  } else if (uri.pathname.length > 1) {
    database = uri.pathname.slice(1);
    if (type === "postgresql" && !database) {
      database = "postgres";
    }
  }
  if (type === "postgresql" && !schema) {
    defaultSchema = "public";
  }
  return {
    type,
    host: exists(uri.hostname) ? uri.hostname : void 0,
    user: exists(uri.username) ? uri.username : void 0,
    port: exists(uri.port) ? Number(uri.port) : void 0,
    password: exists(uri.password) ? uri.password : void 0,
    database,
    schema: schema || defaultSchema,
    uri: connectionString,
    ssl: Boolean(uri.searchParams.get("sslmode")),
    socket: socket || void 0,
    extraFields
  };
}
__name(uriToCredentials, "uriToCredentials");
function databaseTypeToProtocol(databaseType) {
  switch (databaseType) {
    case "postgresql":
    case "cockroachdb":
      return "postgresql:";
    case "mysql":
      return "mysql:";
    case "mongodb":
      return "mongodb:";
    case "sqlite":
      return "sqlite:";
    case "sqlserver":
      return "sqlserver:";
    case "jdbc:sqlserver":
      return "jdbc:sqlserver:";
  }
}
__name(databaseTypeToProtocol, "databaseTypeToProtocol");
function protocolToConnectorType(protocol) {
  switch (protocol) {
    case "postgresql:":
    case "postgres:":
      return "postgresql";
    case "mongodb+srv:":
    case "mongodb:":
      return "mongodb";
    case "mysql:":
      return "mysql";
    case "file:":
    case "sqlite:":
      return "sqlite";
    case "sqlserver:":
    case "jdbc:sqlserver:":
      return "sqlserver";
  }
  throw new Error(`Unknown database type ${protocol}`);
}
__name(protocolToConnectorType, "protocolToConnectorType");
export {
  credentialsToUri,
  protocolToConnectorType,
  uriToCredentials
};
