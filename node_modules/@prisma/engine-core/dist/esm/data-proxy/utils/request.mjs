var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
import { getJSRuntimeName } from "./getJSRuntimeName";
async function request(url2, options2 = {}) {
  const jsRuntimeName = getJSRuntimeName();
  if (jsRuntimeName === "browser") {
    return fetch(url2, options2);
  } else {
    return nodeFetch(url2, options2);
  }
}
__name(request, "request");
function buildHeaders(options2) {
  return {
    ...JSON.parse(JSON.stringify(options2.headers)),
    "Content-Type": "application/json"
  };
}
__name(buildHeaders, "buildHeaders");
function buildOptions(options2) {
  return {
    method: options2.method,
    headers: buildHeaders(options2)
  };
}
__name(buildOptions, "buildOptions");
function buildResponse(incomingData2, response) {
  return {
    json: () => JSON.parse(Buffer.concat(incomingData2).toString()),
    ok: response.statusCode >= 200 && response.statusCode < 300,
    status: response.statusCode,
    url: response.url
  };
}
__name(buildResponse, "buildResponse");
function nodeFetch(url, options = {}) {
  const httpsOptions = buildOptions(options);
  const incomingData = [];
  return new Promise((resolve, reject) => {
    const https = eval(`require('https')`);
    const request = https.request(url, httpsOptions, (response) => {
      response.on("data", (chunk) => incomingData.push(chunk));
      response.on("end", () => resolve(buildResponse(incomingData, response)));
      response.on("error", reject);
    });
    request.on("error", reject);
    request.write(options.body ?? "");
    request.end();
  });
}
__name(nodeFetch, "nodeFetch");
export {
  request
};
