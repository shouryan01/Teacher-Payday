import fs, { promises } from 'fs';
import path, { resolve, join } from 'path';
import { readJSON, existsSync, readJSONSync } from 'fs-extra';
import pkgDir from 'pkg-dir';
import resolveCwd from 'resolve-cwd';
import { spawn } from 'cross-spawn';
import detect from 'detect-port';
import { build as build$1 } from 'esbuild';
import { baseLogger, newline, log } from 'next/dist/server/lib/logging';
import { getProjectRootSync } from 'next/dist/server/lib/utils';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var debug$1 = /*#__PURE__*/require("debug")("blitz:utils");

async function resolveBinAsync(pkg, executable) {
  if (executable === void 0) {
    executable = pkg;
  }

  var packageDir = await pkgDir(resolveCwd(pkg));
  if (!packageDir) throw new Error("Could not find package.json for '" + pkg + "'");

  var _await$readJSON = await readJSON(path.join(packageDir, "package.json")),
      bin = _await$readJSON.bin;

  var binPath = typeof bin === "object" ? bin[executable] : bin;
  if (!binPath) throw new Error("No bin '" + executable + "' in module '" + pkg + "'");
  debug$1("binPath: " + binPath);
  var fullPath = path.join(packageDir, binPath);
  debug$1("fullPath: " + fullPath);
  return fullPath;
}

var standardBuildFolderPath = ".blitz/build";

function isInDocker() {
  var cgroupFile = join("proc", "self", "cgroup");

  if (fs.existsSync(cgroupFile)) {
    var content = fs.readFileSync(cgroupFile, "utf-8");
    return content.includes("docker");
  }

  return false;
}

var defaults = {
  hostname: /*#__PURE__*/isInDocker() ? "0.0.0.0" : "127.0.0.1",
  // -
  env: "prod",
  // -
  buildFolder: standardBuildFolderPath,
  routesFolder: ".blitz/routes",
  // -
  writeManifestFile: true,
  // -
  ignoredPaths: ["./build/**/*", "**/.blitz-*/**/*", "**/.blitz/**/*", "**/.heroku/**/*", "**/.profile.d/**/*", "**/.cache/**/*", "./.config/**/*", "**/.DS_Store", "**/.git/**/*", "**/.next/**/*", "**/*.log", "**/.vercel/**/*", "**/.now/**/*", "**/*.pnp.js", "**/*.sqlite*", "coverage/**/*", ".coverage/**/*", "dist/**/*", "**/node_modules/**/*", "cypress/**/*", "test/**/*", "tests/**/*", "spec/**/*", "specs/**/*", "**/*.test.*", "**/*.spec.*", "**/.yalc/**/*"],
  includePaths: ["**/*"]
};
async function normalize(config) {
  var _config$hostname, _config$buildFolder, _config$routesFolder, _config$isTypeScript, _config$watch, _config$writeManifest;

  var rootFolder = resolve(process.cwd(), config.rootFolder);
  var env = config.env || defaults.env;
  return _extends({}, config, {
    hostname: (_config$hostname = config.hostname) != null ? _config$hostname : defaults.hostname,
    env: env,
    // -
    rootFolder: rootFolder,
    buildFolder: resolve(rootFolder, (_config$buildFolder = config.buildFolder) != null ? _config$buildFolder : defaults.buildFolder),
    routesFolder: resolve(rootFolder, (_config$routesFolder = config.routesFolder) != null ? _config$routesFolder : defaults.routesFolder),
    // -
    isTypeScript: (_config$isTypeScript = config.isTypeScript) != null ? _config$isTypeScript : await getIsTypeScript(rootFolder),
    watch: (_config$watch = config.watch) != null ? _config$watch : env === "dev",
    clean: config.clean,
    // -
    writeManifestFile: (_config$writeManifest = config.writeManifestFile) != null ? _config$writeManifest : defaults.writeManifestFile,
    // -
    ignore: defaults.ignoredPaths.concat(),
    include: defaults.includePaths.concat(),
    // -
    nextBin: await getNextBin(rootFolder)
  });
}

async function getNextBin(rootFolder, _usePatched) {

  var nextBinPkg = "next";
  var nextBin = await resolveBinAsync(nextBinPkg);
  return resolve(rootFolder, nextBin);
}

async function getIsTypeScript(rootFolder) {
  try {
    await promises.access(join(rootFolder, "tsconfig.json"));
    return true;
  } catch (_unused) {
    return false;
  }
}

var debug = /*#__PURE__*/require("debug")("blitz:utils");

function getSpawnEnv(config) {
  var spawnEnv = process.env;
  spawnEnv.FORCE_COLOR = "3";

  if (config.inspect) {
    spawnEnv = _extends({}, spawnEnv, {
      NODE_OPTIONS: "--inspect"
    });
  }

  return spawnEnv;
}

async function createCommandAndPort(config, command) {
  var spawnCommand = [command];
  var availablePort;
  availablePort = await detect({
    port: config.port ? config.port : 3000
  });
  spawnCommand = spawnCommand.concat(["-p", "" + availablePort]);

  if (config.hostname) {
    spawnCommand = spawnCommand.concat(["-H", "" + config.hostname]);
  }

  var spawnEnv = getSpawnEnv(config);
  return {
    spawnCommand: spawnCommand,
    spawnEnv: spawnEnv,
    availablePort: availablePort
  };
}

async function nextStartDev(nextBin, cwd, _manifest, _buildFolder, config) {
  var _await$createCommandA = await createCommandAndPort(config, "dev"),
      spawnCommand = _await$createCommandA.spawnCommand,
      spawnEnv = _await$createCommandA.spawnEnv,
      availablePort = _await$createCommandA.availablePort;

  process.env.BLITZ_DEV_SERVER_ORIGIN = "http://localhost:" + availablePort;
  debug("cwd ", cwd);
  debug("spawn ", nextBin, spawnCommand);
  return new Promise(function (res, rej) {
    if (config.port && availablePort !== config.port) {
      baseLogger({
        displayDateTime: false
      }).error("Couldn't start server on port " + config.port + " because it's already in use");
      rej("");
    } else {
      spawn(nextBin, spawnCommand, {
        cwd: cwd,
        env: spawnEnv,
        stdio: "inherit"
      }).on("exit", function (code) {
        if (code === 0) {
          res();
        } else {
          process.exit(code);
        }
      }).on("error", rej);
    }
  });
}
function nextBuild(nextBin, _buildFolder, _manifest, config) {
  var spawnEnv = getSpawnEnv(config);
  return new Promise(function (res, rej) {
    spawn(nextBin, ["build"], {
      env: spawnEnv,
      stdio: "inherit"
    }).on("exit", function (code) {
      if (code === 0 || code === null) {
        res();
      } else {
        process.exit(code);
      }
    }).on("error", rej);
  });
}
function nextExport(nextBin, config) {
  var spawnEnv = getSpawnEnv(config);
  return new Promise(function (res, rej) {
    spawn(nextBin, ["export"], {
      env: spawnEnv,
      stdio: "inherit"
    }).on("exit", function (code) {
      if (code === 0 || code === null) {
        res();
      } else {
        process.exit(code);
      }
    }).on("error", rej);
  });
}
async function nextStart(nextBin, _buildFolder, config) {
  var _await$createCommandA2 = await createCommandAndPort(config, "start"),
      spawnCommand = _await$createCommandA2.spawnCommand,
      spawnEnv = _await$createCommandA2.spawnEnv,
      availablePort = _await$createCommandA2.availablePort;

  return new Promise(function (res, rej) {
    if (config.port && availablePort !== config.port) {
      baseLogger({
        displayDateTime: false
      }).error("Couldn't start server on port " + config.port + " because it's already in use");
      rej("");
    } else {
      spawn(nextBin, spawnCommand, {
        env: spawnEnv,
        stdio: "inherit"
      }).on("exit", function (code) {
        if (code === 0) {
          res();
        } else {
          process.exit(code);
        }
      }).on("error", function (err) {
        console.error(err);
        rej(err);
      });
    }
  });
}
function getCustomServerPath() {
  var projectRoot = getProjectRootSync();
  var serverPath = path.resolve(path.join(projectRoot, "server.ts"));
  if (existsSync(serverPath)) return serverPath;
  serverPath = path.resolve(path.join(projectRoot, "server.js"));
  if (existsSync(serverPath)) return serverPath;
  serverPath = path.resolve(path.join(projectRoot, "server/index.ts"));
  if (existsSync(serverPath)) return serverPath;
  serverPath = path.resolve(path.join(projectRoot, "server/index.js"));
  if (existsSync(serverPath)) return serverPath;
  throw new Error("Unable to find custom server");
}
function getCustomServerBuildPath() {
  var projectRoot = getProjectRootSync();
  return path.resolve(projectRoot, ".next", "custom-server.js");
}
function customServerExists() {
  try {
    getCustomServerPath();
    return true;
  } catch (_unused) {
    return false;
  }
}

var getEsbuildOptions = function getEsbuildOptions() {
  var _pkg$dependencies, _pkg$devDependencies;

  var pkg = readJSONSync(path.join(pkgDir.sync(), "package.json"));
  return {
    entryPoints: [getCustomServerPath()],
    outfile: getCustomServerBuildPath(),
    format: "cjs",
    bundle: true,
    platform: "node",
    external: ["blitz", "next"].concat(Object.keys(require("blitz/package").dependencies), Object.keys((_pkg$dependencies = pkg == null ? void 0 : pkg.dependencies) != null ? _pkg$dependencies : {}), Object.keys((_pkg$devDependencies = pkg == null ? void 0 : pkg.devDependencies) != null ? _pkg$devDependencies : {}))
  };
};

function buildCustomServer(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      watch = _ref.watch;

  var esbuildOptions = getEsbuildOptions();

  if (watch) {
    esbuildOptions.watch = {
      onRebuild: function onRebuild(error) {
        if (error) {
          baseLogger({
            displayDateTime: false
          }).error("Failed to re-build custom server");
        } else {
          newline();
          log.progress("Custom server changed - rebuilding...");
        }
      }
    };
  }

  return build$1(esbuildOptions);
}
function startCustomServer(_cwd, config, _temp2) {
  var _ref2 = _temp2 === void 0 ? {} : _temp2,
      watch = _ref2.watch;

  process.env.BLITZ_APP_DIR = config.rootFolder;
  var serverBuildPath = getCustomServerBuildPath();
  var spawnEnv = getSpawnEnv(config);

  if (config.env === "prod") {
    spawnEnv = _extends({}, spawnEnv, {
      NODE_ENV: "production"
    });
  }

  return new Promise(function (res, rej) {
    var process;
    var RESTART_CODE = 777777;

    var spawnServer = function spawnServer() {
      process = spawn("node", [serverBuildPath], {
        env: spawnEnv,
        stdio: "inherit"
      }).on("exit", function (code) {
        if (code === 0) {
          res();
        } else if (watch && code === RESTART_CODE) {
          spawnServer();
        } else {
          rej("server.js failed with status code: " + code);
        }
      }).on("error", function (err) {
        console.error(err);
        rej(err);
      });
    };

    var skipDevCustomServerBuild = config.env === "prod";

    if (skipDevCustomServerBuild) {
      spawnServer();
      return;
    } // Handle build & Starting server


    var esbuildOptions = getEsbuildOptions();
    esbuildOptions.watch = watch ? {
      onRebuild: function onRebuild(error) {
        if (error) {
          baseLogger({
            displayDateTime: false
          }).error("Failed to re-build custom server");
        } else {
          newline();
          log.progress("Custom server changed - restarting...");
          newline(); //@ts-ignore -- incorrect TS type from node

          process.exitCode = RESTART_CODE;
          process.kill("SIGABRT");
        }
      }
    } : undefined; // eslint-disable-next-line @typescript-eslint/no-floating-promises

    build$1(esbuildOptions).then(function () {
      spawnServer();
    });
  });
}

async function build(config) {
  var _await$normalize = await normalize(config),
      rootFolder = _await$normalize.rootFolder,
      nextBin = _await$normalize.nextBin,
      watch = _await$normalize.watch;

  await nextBuild(nextBin, rootFolder, {}, config);
  if (customServerExists()) await buildCustomServer({
    watch: watch
  });
}

async function blitzExport(config) {
  var _await$normalize = await normalize(config),
      nextBin = _await$normalize.nextBin;

  await nextExport(nextBin, config);
}

async function dev(config) {
  var _await$normalize = await normalize(_extends({}, config, {
    env: "dev"
  })),
      rootFolder = _await$normalize.rootFolder,
      nextBin = _await$normalize.nextBin;

  if (customServerExists()) {
    var _blitzConfig$customSe, _blitzConfig$customSe2;

    log.success("Using your custom server");

    var _await$import = await import('next/dist/server/config-shared'),
        loadConfigProduction = _await$import.loadConfigProduction;

    var blitzConfig = loadConfigProduction(config.rootFolder);
    var watch = (_blitzConfig$customSe = (_blitzConfig$customSe2 = blitzConfig.customServer) == null ? void 0 : _blitzConfig$customSe2.hotReload) != null ? _blitzConfig$customSe : true;
    await startCustomServer(rootFolder, config, {
      watch: watch
    });
  } else {
    await nextStartDev(nextBin, rootFolder, {}, rootFolder, config);
  }
}

async function prod(config) {
  var _await$normalize = await normalize(config),
      rootFolder = _await$normalize.rootFolder,
      nextBin = _await$normalize.nextBin;

  if (customServerExists()) {
    log.success("Using your custom server");
    await startCustomServer(rootFolder, config);
  } else {
    await nextStart(nextBin, rootFolder, config);
  }
}

export { blitzExport, build, dev, normalize, prod, resolveBinAsync };
