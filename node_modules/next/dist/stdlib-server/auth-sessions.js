"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getSession = getSession;
exports.getAllSessionHandlesForUser = getAllSessionHandlesForUser;
exports.setPublicDataForUser = setPublicDataForUser;
exports.sessionMiddleware = exports.simpleRolesIsAuthorized = void 0;
var _logging = require("../server/lib/logging");
var _b64Lite = require("b64-lite");
var _cookie = _interopRequireDefault(require("next/dist/compiled/cookie"));
var _fs = _interopRequireDefault(require("fs"));
var _path = require("path");
var _jsonwebtoken = require("next/dist/compiled/jsonwebtoken");
var _apiUtils = require("../server/api-utils");
var _index = require("../stdlib/index");
var _index1 = require("./index");
var _constants = require("../data-client/constants");
var _authUtils = require("./auth-utils");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {
        };
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}
const debug = require('debug')('blitz:session');
function assert(condition, message) {
    if (!condition) throw new Error(message);
}
const getDb = ()=>{
    if (!process.env.BLITZ_APP_DIR) {
        throw new Error('Internal Blitz Error: process.env.BLITZ_APP_DIR is not set');
    }
    const projectRoot = process.env.BLITZ_APP_DIR;
    let path = (0, _path).join(projectRoot, '.next/server/blitz-db.js');
    if (!_fs.default.existsSync(path)) {
        path = (0, _path).join(projectRoot, '.next/serverless/blitz-db.js');
    }
    // eslint-disable-next-line no-eval -- block webpack from following this module path
    return eval('require')(path).default;
};
const defaultConfig = {
    sessionExpiryMinutes: 30 * 24 * 60,
    method: 'essential',
    sameSite: 'lax',
    publicDataKeysToSyncAcrossSessions: [
        'role',
        'roles'
    ],
    secureCookies: !process.env.DISABLE_SECURE_COOKIES && process.env.NODE_ENV === 'production',
    getSession: (handle)=>getDb().session.findFirst({
            where: {
                handle
            }
        })
    ,
    getSessions: (userId)=>getDb().session.findMany({
            where: {
                userId
            }
        })
    ,
    createSession: (session)=>{
        let user;
        if (session.userId) {
            user = {
                connect: {
                    id: session.userId
                }
            };
        }
        return getDb().session.create({
            data: _objectSpread({
            }, session, {
                userId: undefined,
                user
            })
        });
    },
    updateSession: _asyncToGenerator(function*(handle, session) {
        try {
            return yield getDb().session.update({
                where: {
                    handle
                },
                data: session
            });
        } catch (error) {
            // Session doesn't exist in DB for some reason, so create it
            if (error.code === 'P2016') {
                (0, _logging).baseLogger({
                    displayDateTime: false
                }).warn("Could not update session because it's not in the DB");
            } else {
                throw error;
            }
        }
    }),
    deleteSession: (handle)=>getDb().session.delete({
            where: {
                handle
            }
        })
    ,
    isAuthorized: ()=>{
        throw new Error('No isAuthorized implementation provided');
    }
};
const simpleRolesIsAuthorized = ({ ctx , args ,  })=>{
    const [roleOrRoles] = args;
    const publicData = ctx.session.$publicData;
    if ('role' in publicData && 'roles' in publicData) {
        throw new Error("Session publicData can only have only `role` or `roles`, but not both.'");
    }
    let roles = [];
    if ('role' in publicData) {
        if (typeof publicData.role !== 'string') {
            throw new Error('Session publicData.role field must be a string');
        }
        roles.push(publicData.role);
    } else if ('roles' in publicData) {
        if (!Array.isArray(publicData.roles)) {
            throw new Error('Session `publicData.roles` is not an array, but it must be');
        }
        roles = publicData.roles;
    } else {
        throw new Error('Session publicData is missing the required `role` or roles` field');
    }
    // No roles required, so all roles allowed
    if (!roleOrRoles) return true;
    const rolesToAuthorize = [];
    if (Array.isArray(roleOrRoles)) {
        rolesToAuthorize.push(...roleOrRoles);
    } else if (roleOrRoles) {
        rolesToAuthorize.push(roleOrRoles);
    }
    for (const role of rolesToAuthorize){
        if (roles.includes(role)) return true;
    }
    return false;
};
exports.simpleRolesIsAuthorized = simpleRolesIsAuthorized;
const sessionMiddleware = (sessionConfig = {
})=>{
    assert(sessionConfig.isAuthorized, 'You must provide an authorization implementation to sessionMiddleware as isAuthorized(userRoles, input)');
    global.sessionConfig = _objectSpread({
    }, defaultConfig, sessionConfig);
    var _cookiePrefix;
    // Checks if cookie prefix from configuration has
    // non-alphanumeric characters and throws error
    const cookiePrefix = (_cookiePrefix = global.sessionConfig.cookiePrefix) !== null && _cookiePrefix !== void 0 ? _cookiePrefix : 'blitz';
    assert(cookiePrefix.match(/^[a-zA-Z0-9-_]+$/), `The cookie prefix used has invalid characters. Only alphanumeric characters, "-"  and "_" character are supported`);
    const blitzSessionMiddleware = _asyncToGenerator(function*(req, res, next) {
        debug('Starting sessionMiddleware...');
        if (!res.blitzCtx.session) {
            // This function also saves session to res.blitzCtx
            yield getSession(req, res);
        }
        return next();
    });
    blitzSessionMiddleware.config = {
        name: 'blitzSessionMiddleware',
        cookiePrefix
    };
    return blitzSessionMiddleware;
};
exports.sessionMiddleware = sessionMiddleware;
// const isNextApiRequest = (req: NextApiRequest | IncomingMessage): req is NextApiRequest => {
//   return "cookies" in req
// }
function ensureNextApiRequest(req) {
    if (!('cookies' in req)) {
        req.cookies = (0, _apiUtils).getCookieParser(req.headers)();
    }
}
// const isMiddlewareApResponse = (
//   res: MiddlewareResponse | ServerResponse,
// ): res is MiddlewareResponse => {
//   return "blitzCtx" in res
// }
function ensureMiddlewareResponse(res) {
    if (!('blitzCtx' in res)) {
        res.blitzCtx = {
        };
    }
}
function _getSession() {
    _getSession = _asyncToGenerator(function*(req, res) {
        ensureNextApiRequest(req);
        ensureMiddlewareResponse(res);
        debug('cookiePrefix', process.env.__BLITZ_SESSION_COOKIE_PREFIX);
        let response = res;
        if (response.blitzCtx.session) {
            return response.blitzCtx.session;
        }
        let sessionKernel = yield getSessionKernel(req, res);
        if (sessionKernel) {
            debug('Got existing session', sessionKernel);
        }
        if (!sessionKernel) {
            debug('No session found, creating anonymous session');
            sessionKernel = yield createAnonymousSession(req, res);
        }
        const sessionContext = makeProxyToPublicData(new SessionContextClass(req, res, sessionKernel));
        response.blitzCtx.session = sessionContext;
        return sessionContext;
    });
    return _getSession.apply(this, arguments);
}
function getSession(req, res) {
    return _getSession.apply(this, arguments);
}
const makeProxyToPublicData = (ctxClass)=>{
    return new Proxy(ctxClass, {
        get (target, prop, receiver) {
            if (prop in target || prop === 'then') {
                return Reflect.get(target, prop, receiver);
            } else {
                return Reflect.get(target.$publicData, prop, receiver);
            }
        }
    });
};
class SessionContextClass {
    get $handle() {
        return this._kernel.handle;
    }
    get userId() {
        return this._kernel.publicData.userId;
    }
    get $publicData() {
        return this._kernel.publicData;
    }
    $authorize(...args) {
        const e = new _index.AuthenticationError();
        Error.captureStackTrace(e, this.$authorize);
        if (!this.userId) throw e;
        if (!this.$isAuthorized(...args)) {
            const err = new _index.AuthorizationError();
            Error.captureStackTrace(err, this.$authorize);
            throw err;
        }
    }
    $isAuthorized(...args) {
        if (!this.userId) return false;
        return global.sessionConfig.isAuthorized({
            ctx: this._res.blitzCtx,
            args
        });
    }
    $create(publicData, privateData) {
        return _asyncToGenerator((function*() {
            this._kernel = yield createNewSession({
                req: this._req,
                res: this._res,
                publicData,
                privateData,
                jwtPayload: this._kernel.jwtPayload,
                anonymous: false
            });
        }).bind(this))();
    }
    $revoke() {
        return _asyncToGenerator((function*() {
            this._kernel = yield revokeSession(this._req, this._res, this.$handle);
        }).bind(this))();
    }
    $revokeAll() {
        return _asyncToGenerator((function*() {
            // revoke the current session which uses req/res
            yield this.$revoke();
            // revoke other sessions for which there is no req/res object
            yield revokeAllSessionsForUser(this.$publicData.userId);
            return;
        }).bind(this))();
    }
    $setPublicData(data) {
        return _asyncToGenerator((function*() {
            if (this.userId) {
                yield syncPubicDataFieldsForUserIfNeeded(this.userId, data);
            }
            this._kernel.publicData = yield setPublicData(this._req, this._res, this._kernel, data);
        }).bind(this))();
    }
    $getPrivateData() {
        return _asyncToGenerator((function*() {
            return (yield getPrivateData(this.$handle)) || {
            };
        }).bind(this))();
    }
    $setPrivateData(data) {
        return setPrivateData(this._kernel, data);
    }
    constructor(req, res, kernel){
        this._req = req;
        this._res = res;
        this._kernel = kernel;
    }
}
exports.SessionContextClass = SessionContextClass;
// --------------------------------
// Token/handle utils
// --------------------------------
const TOKEN_LENGTH = 32;
const generateEssentialSessionHandle = ()=>{
    return (0, _authUtils).generateToken(TOKEN_LENGTH) + _constants.HANDLE_SEPARATOR + _constants.SESSION_TYPE_OPAQUE_TOKEN_SIMPLE;
};
const generateAnonymousSessionHandle = ()=>{
    return (0, _authUtils).generateToken(TOKEN_LENGTH) + _constants.HANDLE_SEPARATOR + _constants.SESSION_TYPE_ANONYMOUS_JWT;
};
const createSessionToken = (handle, publicData)=>{
    // We store the hashed public data in the opaque token so that when we verify,
    // we can detect changes in it and return a new set of tokens if necessary.
    let publicDataString;
    if (typeof publicData === 'string') {
        publicDataString = publicData;
    } else {
        publicDataString = JSON.stringify(publicData);
    }
    return (0, _b64Lite).toBase64([
        handle,
        (0, _authUtils).generateToken(TOKEN_LENGTH),
        (0, _authUtils).hash256(publicDataString),
        _constants.SESSION_TOKEN_VERSION_0, 
    ].join(_constants.TOKEN_SEPARATOR));
};
const parseSessionToken = (token)=>{
    const [handle, id, hashedPublicData, version] = (0, _b64Lite).fromBase64(token).split(_constants.TOKEN_SEPARATOR);
    if (!handle || !id || !hashedPublicData || !version) {
        throw new _index.AuthenticationError('Failed to parse session token');
    }
    return {
        handle,
        id,
        hashedPublicData,
        version
    };
};
const createPublicDataToken = (publicData)=>{
    const payload = typeof publicData === 'string' ? publicData : JSON.stringify(publicData);
    return (0, _b64Lite).toBase64(payload);
};
const createAntiCSRFToken = ()=>(0, _authUtils).generateToken(TOKEN_LENGTH)
;
const getSessionSecretKey = ()=>{
    if (process.env.NODE_ENV === 'production') {
        if (!process.env.SESSION_SECRET_KEY && process.env.SECRET_SESSION_KEY) {
            throw new Error("You need to rename the SECRET_SESSION_KEY environment variable to SESSION_SECRET_KEY (but don't feel bad, we've all done it :)");
        }
        assert(process.env.SESSION_SECRET_KEY, 'You must provide the SESSION_SECRET_KEY environment variable in production. This is used to sign and verify tokens. It should be 32 chars long.');
        assert(process.env.SESSION_SECRET_KEY.length >= 32, 'The SESSION_SECRET_KEY environment variable must be at least 32 bytes for sufficent token security');
        return process.env.SESSION_SECRET_KEY;
    } else {
        return process.env.SESSION_SECRET_KEY || 'default-dev-secret';
    }
};
const JWT_NAMESPACE = 'blitzjs';
const JWT_ISSUER = 'blitzjs';
const JWT_AUDIENCE = 'blitzjs';
const JWT_ANONYMOUS_SUBJECT = 'anonymous';
const JWT_ALGORITHM = 'HS256';
const createAnonymousSessionToken = (payload)=>{
    return (0, _jsonwebtoken).sign({
        [JWT_NAMESPACE]: payload
    }, getSessionSecretKey(), {
        algorithm: JWT_ALGORITHM,
        issuer: JWT_ISSUER,
        audience: JWT_AUDIENCE,
        subject: JWT_ANONYMOUS_SUBJECT
    });
};
const parseAnonymousSessionToken = (token)=>{
    // This must happen outside the try/catch because it could throw an error
    // about a missing environment variable
    const secret = getSessionSecretKey();
    try {
        const fullPayload = (0, _jsonwebtoken).verify(token, secret, {
            algorithms: [
                JWT_ALGORITHM
            ],
            issuer: JWT_ISSUER,
            audience: JWT_AUDIENCE,
            subject: JWT_ANONYMOUS_SUBJECT
        });
        if (typeof fullPayload === 'object') {
            return fullPayload[JWT_NAMESPACE];
        } else {
            return null;
        }
    } catch (error) {
        return null;
    }
};
const setCookie = (res1, cookieStr)=>{
    const getCookieName = (c)=>c.split('=', 2)[0]
    ;
    const appendCookie = ()=>append(res1, 'Set-Cookie', cookieStr)
    ;
    const cookiesHeader = res1.getHeader('Set-Cookie');
    const cookieName = getCookieName(cookieStr);
    if (typeof cookiesHeader !== 'string' && !Array.isArray(cookiesHeader)) {
        appendCookie();
        return;
    }
    if (typeof cookiesHeader === 'string') {
        if (cookieName === getCookieName(cookiesHeader)) {
            res1.setHeader('Set-Cookie', cookieStr);
        } else {
            appendCookie();
        }
    } else {
        for(let i = 0; i < cookiesHeader.length; i++){
            if (cookieName === getCookieName(cookiesHeader[i])) {
                cookiesHeader[i] = cookieStr;
                res1.setHeader('Set-Cookie', cookieStr);
                return;
            }
        }
        appendCookie();
    }
};
const setHeader = (res1, name, value)=>{
    res1.setHeader(name, value);
    if ('_blitz' in res1) {
        res1._blitz[name] = value;
    }
};
const setSessionCookie = (req1, res1, sessionToken, expiresAt)=>{
    setCookie(res1, _cookie.default.serialize((0, _constants).COOKIE_SESSION_TOKEN(), sessionToken, {
        path: '/',
        httpOnly: true,
        secure: global.sessionConfig.secureCookies && !(0, _index1).isLocalhost(req1),
        sameSite: global.sessionConfig.sameSite,
        domain: global.sessionConfig.domain,
        expires: expiresAt
    }));
};
const setAnonymousSessionCookie = (req1, res1, token, expiresAt)=>{
    setCookie(res1, _cookie.default.serialize((0, _constants).COOKIE_ANONYMOUS_SESSION_TOKEN(), token, {
        path: '/',
        httpOnly: true,
        secure: global.sessionConfig.secureCookies && !(0, _index1).isLocalhost(req1),
        sameSite: global.sessionConfig.sameSite,
        domain: global.sessionConfig.domain,
        expires: expiresAt
    }));
};
const setCSRFCookie = (req1, res1, antiCSRFToken, expiresAt)=>{
    debug('setCSRFCookie', antiCSRFToken);
    assert(antiCSRFToken !== undefined, 'Internal error: antiCSRFToken is being set to undefined');
    setCookie(res1, _cookie.default.serialize((0, _constants).COOKIE_CSRF_TOKEN(), antiCSRFToken, {
        path: '/',
        secure: global.sessionConfig.secureCookies && !(0, _index1).isLocalhost(req1),
        sameSite: global.sessionConfig.sameSite,
        domain: global.sessionConfig.domain,
        expires: expiresAt
    }));
};
const setPublicDataCookie = (req1, res1, publicDataToken, expiresAt)=>{
    setHeader(res1, _constants.HEADER_PUBLIC_DATA_TOKEN, 'updated');
    setCookie(res1, _cookie.default.serialize((0, _constants).COOKIE_PUBLIC_DATA_TOKEN(), publicDataToken, {
        path: '/',
        secure: global.sessionConfig.secureCookies && !(0, _index1).isLocalhost(req1),
        sameSite: global.sessionConfig.sameSite,
        domain: global.sessionConfig.domain,
        expires: expiresAt
    }));
};
function _getSessionKernel() {
    _getSessionKernel = // --------------------------------
    // Get Session
    // --------------------------------
    _asyncToGenerator(function*(req1, res1) {
        const anonymousSessionToken = req1.cookies[(0, _constants).COOKIE_ANONYMOUS_SESSION_TOKEN()];
        const sessionToken = req1.cookies[(0, _constants).COOKIE_SESSION_TOKEN()] // for essential method
        ;
        const idRefreshToken = req1.cookies[(0, _constants).COOKIE_REFRESH_TOKEN()] // for advanced method
        ;
        const enableCsrfProtection = req1.method !== 'GET' && req1.method !== 'OPTIONS' && req1.method !== 'HEAD' && !process.env.DANGEROUSLY_DISABLE_CSRF_PROTECTION;
        const antiCSRFToken = req1.headers[_constants.HEADER_CSRF];
        if (sessionToken) {
            debug('[getSessionKernel] Request has sessionToken');
            const { handle , version , hashedPublicData  } = parseSessionToken(sessionToken);
            if (!handle) {
                debug('No handle in sessionToken');
                return null;
            }
            if (version !== _constants.SESSION_TOKEN_VERSION_0) {
                console.log(new _index.AuthenticationError('Session token version is not ' + _constants.SESSION_TOKEN_VERSION_0));
                return null;
            }
            debug('global session config', global.sessionConfig);
            const persistedSession = yield global.sessionConfig.getSession(handle);
            if (!persistedSession) {
                debug('Session not found in DB');
                return null;
            }
            if (!persistedSession.antiCSRFToken) {
                throw new Error('Internal error: persistedSession.antiCSRFToken is empty');
            }
            if (persistedSession.hashedSessionToken !== (0, _authUtils).hash256(sessionToken)) {
                debug('sessionToken hash did not match');
                debug('persisted: ', persistedSession.hashedSessionToken);
                debug('in req: ', (0, _authUtils).hash256(sessionToken));
                return null;
            }
            if (persistedSession.expiresAt && (0, _index).isPast(persistedSession.expiresAt)) {
                debug('Session expired');
                return null;
            }
            if (enableCsrfProtection && persistedSession.antiCSRFToken !== antiCSRFToken) {
                if (!antiCSRFToken) {
                    (0, _logging).baseLogger({
                        displayDateTime: false
                    }).warn(`This request is missing the ${_constants.HEADER_CSRF} header. You can learn about adding this here: https://blitzjs.com/docs/session-management#manual-api-requests`);
                }
                setHeader(res1, _constants.HEADER_CSRF_ERROR, 'true');
                throw new _index.CSRFTokenMismatchError();
            }
            /*
     * Session Renewal - Will renew if any of the following is true
     * 1) publicData has changed
     * 2) 1/4 of expiry time has elasped
     *
     *  But only renew with non-GET requests because a GET request could be from a
     *  browser level navigation
     */ if (req1.method !== 'GET') {
                var _publicData;
                // The publicData in the DB could have been updated since this client last made
                // a request. If so, then we generate a new access token
                const hasPublicDataChanged = (0, _authUtils).hash256((_publicData = persistedSession.publicData) !== null && _publicData !== void 0 ? _publicData : undefined) !== hashedPublicData;
                if (hasPublicDataChanged) {
                    debug('PublicData has changed since the last request');
                }
                // Check if > 1/4th of the expiry time has passed
                // (since we are doing a rolling expiry window).
                const hasQuarterExpiryTimePassed = persistedSession.expiresAt && (0, _index).differenceInMinutes(persistedSession.expiresAt, new Date()) < 0.75 * global.sessionConfig.sessionExpiryMinutes;
                if (hasQuarterExpiryTimePassed) {
                    debug('quarter expiry time has passed');
                    debug('Persisted expire time', persistedSession.expiresAt);
                }
                if (hasPublicDataChanged || hasQuarterExpiryTimePassed) {
                    yield refreshSession(req1, res1, {
                        handle,
                        publicData: JSON.parse(persistedSession.publicData || ''),
                        jwtPayload: null,
                        antiCSRFToken: persistedSession.antiCSRFToken,
                        sessionToken
                    }, {
                        publicDataChanged: hasPublicDataChanged
                    });
                }
            }
            return {
                handle,
                publicData: JSON.parse(persistedSession.publicData || ''),
                jwtPayload: null,
                antiCSRFToken: persistedSession.antiCSRFToken,
                sessionToken
            };
        } else if (idRefreshToken) {
            // TODO: advanced method
            return null;
        // Important: check anonymousSessionToken token as the very last thing
        } else if (anonymousSessionToken) {
            debug('Request has anonymousSessionToken');
            const payload = parseAnonymousSessionToken(anonymousSessionToken);
            if (!payload) {
                debug('Payload empty');
                return null;
            }
            if (enableCsrfProtection && payload.antiCSRFToken !== antiCSRFToken) {
                if (!antiCSRFToken) {
                    (0, _logging).baseLogger({
                        displayDateTime: false
                    }).warn(`This request is missing the ${_constants.HEADER_CSRF} header. You can learn about adding this here: https://blitzjs.com/docs/session-management#manual-api-requests`);
                }
                setHeader(res1, _constants.HEADER_CSRF_ERROR, 'true');
                throw new _index.CSRFTokenMismatchError();
            }
            return {
                handle: payload.handle,
                publicData: payload.publicData,
                antiCSRFToken: payload.antiCSRFToken,
                jwtPayload: payload,
                anonymousSessionToken
            };
        }
        // No session exists
        return null;
    });
    return _getSessionKernel.apply(this, arguments);
}
function getSessionKernel(req1, res1) {
    return _getSessionKernel.apply(this, arguments);
}
function _createNewSession() {
    _createNewSession = _asyncToGenerator(function*(args) {
        const { req: req1 , res: res1  } = args;
        assert(args.publicData.userId !== undefined, 'You must provide publicData.userId');
        const antiCSRFToken = createAntiCSRFToken();
        if (args.anonymous) {
            debug('Creating new anonymous session');
            const handle = generateAnonymousSessionHandle();
            const payload = {
                isAnonymous: true,
                handle,
                publicData: args.publicData,
                antiCSRFToken
            };
            const anonymousSessionToken = createAnonymousSessionToken(payload);
            const publicDataToken = createPublicDataToken(args.publicData);
            const expiresAt = (0, _index).addYears(new Date(), 30);
            setAnonymousSessionCookie(req1, res1, anonymousSessionToken, expiresAt);
            setCSRFCookie(req1, res1, antiCSRFToken, expiresAt);
            setPublicDataCookie(req1, res1, publicDataToken, expiresAt);
            // Clear the essential session cookie in case it was previously set
            setSessionCookie(req1, res1, '', new Date(0));
            setHeader(res1, _constants.HEADER_SESSION_CREATED, 'true');
            return {
                handle,
                publicData: args.publicData,
                jwtPayload: payload,
                antiCSRFToken,
                anonymousSessionToken
            };
        } else if (global.sessionConfig.method === 'essential') {
            var ref, ref1;
            debug('Creating new session');
            const newPublicData = _objectSpread({
            }, ((ref = args.jwtPayload) === null || ref === void 0 ? void 0 : ref.publicData) || {
            }, args.publicData);
            assert(newPublicData.userId, 'You must provide a non-empty userId as publicData.userId');
            // This carries over any private data from the anonymous session
            let existingPrivateData = {
            };
            if ((ref1 = args.jwtPayload) === null || ref1 === void 0 ? void 0 : ref1.isAnonymous) {
                const session = yield global.sessionConfig.getSession(args.jwtPayload.handle);
                if (session) {
                    if (session.privateData) {
                        existingPrivateData = JSON.parse(session.privateData);
                    }
                    // Delete the previous anonymous session
                    yield global.sessionConfig.deleteSession(args.jwtPayload.handle);
                }
            }
            const newPrivateData = _objectSpread({
            }, existingPrivateData, args.privateData);
            const expiresAt = (0, _index).addMinutes(new Date(), global.sessionConfig.sessionExpiryMinutes);
            const handle = generateEssentialSessionHandle();
            const sessionToken = createSessionToken(handle, newPublicData);
            const publicDataToken = createPublicDataToken(newPublicData);
            yield global.sessionConfig.createSession({
                expiresAt,
                handle,
                userId: newPublicData.userId,
                hashedSessionToken: (0, _authUtils).hash256(sessionToken),
                antiCSRFToken,
                publicData: JSON.stringify(newPublicData),
                privateData: JSON.stringify(newPrivateData)
            });
            setSessionCookie(req1, res1, sessionToken, expiresAt);
            setCSRFCookie(req1, res1, antiCSRFToken, expiresAt);
            setPublicDataCookie(req1, res1, publicDataToken, expiresAt);
            // Clear the anonymous session cookie in case it was previously set
            setAnonymousSessionCookie(req1, res1, '', new Date(0));
            setHeader(res1, _constants.HEADER_SESSION_CREATED, 'true');
            return {
                handle,
                publicData: newPublicData,
                jwtPayload: null,
                antiCSRFToken,
                sessionToken
            };
        } else if (global.sessionConfig.method === 'advanced') {
            throw new Error('The advanced method is not yet supported');
        } else {
            throw new Error(`Session management method ${global.sessionConfig.method} is invalid. Supported methods are "essential" and "advanced"`);
        }
    });
    return _createNewSession.apply(this, arguments);
}
function createNewSession(args) {
    return _createNewSession.apply(this, arguments);
}
function _createAnonymousSession() {
    _createAnonymousSession = _asyncToGenerator(function*(req1, res1) {
        return yield createNewSession({
            req: req1,
            res: res1,
            publicData: {
                userId: null
            },
            anonymous: true
        });
    });
    return _createAnonymousSession.apply(this, arguments);
}
function createAnonymousSession(req1, res1) {
    return _createAnonymousSession.apply(this, arguments);
}
function _refreshSession() {
    _refreshSession = // --------------------------------
    // Session/DB utils
    // --------------------------------
    _asyncToGenerator(function*(req1, res1, sessionKernel, { publicDataChanged  }) {
        var ref5;
        debug('Refreshing session', sessionKernel);
        if ((ref5 = sessionKernel.jwtPayload) === null || ref5 === void 0 ? void 0 : ref5.isAnonymous) {
            const payload = _objectSpread({
            }, sessionKernel.jwtPayload, {
                publicData: sessionKernel.publicData
            });
            const anonymousSessionToken = createAnonymousSessionToken(payload);
            const publicDataToken = createPublicDataToken(sessionKernel.publicData);
            const expiresAt = (0, _index).addYears(new Date(), 30);
            setAnonymousSessionCookie(req1, res1, anonymousSessionToken, expiresAt);
            setPublicDataCookie(req1, res1, publicDataToken, expiresAt);
            setCSRFCookie(req1, res1, sessionKernel.antiCSRFToken, expiresAt);
        } else if (global.sessionConfig.method === 'essential' && 'sessionToken' in sessionKernel) {
            const expiresAt = (0, _index).addMinutes(new Date(), global.sessionConfig.sessionExpiryMinutes);
            const publicDataToken = createPublicDataToken(sessionKernel.publicData);
            let sessionToken;
            // Only generate new session token if public data actually changed
            // Otherwise if new session token is generated just for refresh, then
            // we have race condition bugs
            if (publicDataChanged) {
                sessionToken = createSessionToken(sessionKernel.handle, sessionKernel.publicData);
            } else {
                sessionToken = sessionKernel.sessionToken;
            }
            setSessionCookie(req1, res1, sessionToken, expiresAt);
            setPublicDataCookie(req1, res1, publicDataToken, expiresAt);
            setCSRFCookie(req1, res1, sessionKernel.antiCSRFToken, expiresAt);
            debug('Updating session in db with', {
                expiresAt
            });
            if (publicDataChanged) {
                yield global.sessionConfig.updateSession(sessionKernel.handle, {
                    expiresAt,
                    hashedSessionToken: (0, _authUtils).hash256(sessionToken),
                    publicData: JSON.stringify(sessionKernel.publicData)
                });
            } else {
                yield global.sessionConfig.updateSession(sessionKernel.handle, {
                    expiresAt
                });
            }
        } else if (global.sessionConfig.method === 'advanced') {
            throw new Error('refreshSession() not implemented for advanced method');
        }
    });
    return _refreshSession.apply(this, arguments);
}
function refreshSession(req1, res1, sessionKernel, _) {
    return _refreshSession.apply(this, arguments);
}
function _getAllSessionHandlesForUser() {
    _getAllSessionHandlesForUser = _asyncToGenerator(function*(userId) {
        return (yield global.sessionConfig.getSessions(userId)).map((session)=>session.handle
        );
    });
    return _getAllSessionHandlesForUser.apply(this, arguments);
}
function getAllSessionHandlesForUser(userId) {
    return _getAllSessionHandlesForUser.apply(this, arguments);
}
function _syncPubicDataFieldsForUserIfNeeded() {
    _syncPubicDataFieldsForUserIfNeeded = _asyncToGenerator(function*(userId, data) {
        var ref5;
        const dataToSync = {
        };
        (ref5 = global.sessionConfig.publicDataKeysToSyncAcrossSessions) === null || ref5 === void 0 ? void 0 : ref5.forEach((key)=>{
            if (data[key]) {
                dataToSync[key] = data[key];
            }
        });
        if (Object.keys(dataToSync).length) {
            const sessions = yield global.sessionConfig.getSessions(userId);
            for (const session of sessions){
                const publicData = JSON.stringify(_objectSpread({
                }, session.publicData ? JSON.parse(session.publicData) : {
                }, dataToSync));
                yield global.sessionConfig.updateSession(session.handle, {
                    publicData
                });
            }
        }
    });
    return _syncPubicDataFieldsForUserIfNeeded.apply(this, arguments);
}
function syncPubicDataFieldsForUserIfNeeded(userId, data) {
    return _syncPubicDataFieldsForUserIfNeeded.apply(this, arguments);
}
function _revokeSession() {
    _revokeSession = _asyncToGenerator(function*(req1, res1, handle, anonymous = false) {
        debug('Revoking session', handle);
        if (!anonymous) {
            try {
                yield global.sessionConfig.deleteSession(handle);
            } catch (error) {
            // Ignore any errors, like if session doesn't exist in DB
            }
        }
        // Go ahead and create a new anon session. This
        // This fixes race condition where all client side queries get refreshed
        // in parallel and each creates a new anon session
        // https://github.com/blitz-js/blitz/issues/2746
        return createAnonymousSession(req1, res1);
    });
    return _revokeSession.apply(this, arguments);
}
function revokeSession(req1, res1, handle) {
    return _revokeSession.apply(this, arguments);
}
function _revokeAllSessionsForUser() {
    _revokeAllSessionsForUser = _asyncToGenerator(function*(userId) {
        let sessionHandles = (yield global.sessionConfig.getSessions(userId)).map((session)=>session.handle
        );
        let revoked = [];
        for (const handle of sessionHandles){
            try {
                yield global.sessionConfig.deleteSession(handle);
            } catch (error) {
            // Ignore any errors, like if session doesn't exist in DB
            }
            revoked.push(handle);
        }
        return revoked;
    });
    return _revokeAllSessionsForUser.apply(this, arguments);
}
function revokeAllSessionsForUser(userId) {
    return _revokeAllSessionsForUser.apply(this, arguments);
}
function _getPublicData() {
    _getPublicData = _asyncToGenerator(function*(sessionKernel) {
        var ref5;
        if ((ref5 = sessionKernel.jwtPayload) === null || ref5 === void 0 ? void 0 : ref5.publicData) {
            var ref6;
            return (ref6 = sessionKernel.jwtPayload) === null || ref6 === void 0 ? void 0 : ref6.publicData;
        } else {
            const session = yield global.sessionConfig.getSession(sessionKernel.handle);
            if (!session) {
                throw new Error("getPublicData() failed because handle doesn't exist " + sessionKernel.handle);
            }
            if (session.publicData) {
                return JSON.parse(session.publicData);
            } else {
                return {
                };
            }
        }
    });
    return _getPublicData.apply(this, arguments);
}
function getPublicData(sessionKernel) {
    return _getPublicData.apply(this, arguments);
}
function _getPrivateData() {
    _getPrivateData = _asyncToGenerator(function*(handle) {
        const session = yield global.sessionConfig.getSession(handle);
        if (session && session.privateData) {
            return JSON.parse(session.privateData);
        } else {
            return null;
        }
    });
    return _getPrivateData.apply(this, arguments);
}
function getPrivateData(handle) {
    return _getPrivateData.apply(this, arguments);
}
function _setPrivateData() {
    _setPrivateData = _asyncToGenerator(function*(sessionKernel, data) {
        let existingPrivateData = yield getPrivateData(sessionKernel.handle);
        if (existingPrivateData === null) {
            // Anonymous sessions may not exist in the DB yet
            try {
                yield global.sessionConfig.createSession({
                    handle: sessionKernel.handle
                });
            } catch (error) {
            }
            existingPrivateData = {
            };
        }
        const privateData = JSON.stringify(_objectSpread({
        }, existingPrivateData, data));
        yield global.sessionConfig.updateSession(sessionKernel.handle, {
            privateData
        });
    });
    return _setPrivateData.apply(this, arguments);
}
function setPrivateData(sessionKernel, data) {
    return _setPrivateData.apply(this, arguments);
}
function _setPublicData() {
    _setPublicData = _asyncToGenerator(function*(req1, res1, sessionKernel, data) {
        // Don't allow updating userId
        delete data.userId;
        const publicData = _objectSpread({
        }, (yield getPublicData(sessionKernel)), data);
        yield refreshSession(req1, res1, _objectSpread({
        }, sessionKernel, {
            publicData
        }), {
            publicDataChanged: true
        });
        return publicData;
    });
    return _setPublicData.apply(this, arguments);
}
function setPublicData(req1, res1, sessionKernel, data) {
    return _setPublicData.apply(this, arguments);
}
function _setPublicDataForUser() {
    _setPublicDataForUser = _asyncToGenerator(function*(userId, data) {
        // Don't allow updating userId
        delete data.userId;
        const sessions = yield global.sessionConfig.getSessions(userId);
        for (const session of sessions){
            // Merge data
            const publicData = JSON.stringify(_objectSpread({
            }, JSON.parse(session.publicData || ''), data));
            yield global.sessionConfig.updateSession(session.handle, {
                publicData
            });
        }
    });
    return _setPublicDataForUser.apply(this, arguments);
}
function setPublicDataForUser(userId, data) {
    return _setPublicDataForUser.apply(this, arguments);
}
/**
 * Append additional header `field` with value `val`.
 *
 * Example:
 *
 *    append(res, 'Set-Cookie', 'foo=bar; Path=/; HttpOnly');
 *
 * @param {ServerResponse} res
 * @param {string} field
 * @param {string| string[]} val
 */ function append(res1, field, val) {
    let prev = res1.getHeader(field);
    let value = val;
    if (prev !== undefined) {
        // concat the new and prev vals
        value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [
            prev
        ].concat(val) : [
            prev,
            val
        ];
    }
    value = Array.isArray(value) ? value.map(String) : String(value);
    res1.setHeader(field, value);
    return res1;
}

//# sourceMappingURL=auth-sessions.js.map