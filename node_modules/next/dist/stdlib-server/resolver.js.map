{"version":3,"sources":["../../stdlib-server/resolver.ts"],"sourcesContent":["import {\n  AuthenticatedSessionContext,\n  Ctx,\n  SessionContext,\n  SessionContextBase,\n} from 'next/types'\nimport { Await, EnsurePromise } from 'next/types/utils'\nimport type { input as zInput, output as zOutput, ZodTypeAny } from 'zod'\nimport { ParserType } from '../types/index'\n\ninterface ResultWithContext<Result = unknown, Context = unknown> {\n  __blitz: true\n  value: Result\n  ctx: Context\n}\nfunction isResultWithContext(x: unknown): x is ResultWithContext {\n  return (\n    typeof x === 'object' &&\n    x !== null &&\n    'ctx' in x &&\n    (x as ResultWithContext).__blitz === true\n  )\n}\n\nexport interface AuthenticatedMiddlewareCtx extends Omit<Ctx, 'session'> {\n  session: AuthenticatedSessionContext\n}\n\ntype PipeFn<Prev, Next, PrevCtx, NextCtx = PrevCtx> = (\n  i: Await<Prev>,\n  c: PrevCtx\n) => Next extends ResultWithContext\n  ? never\n  : Next | ResultWithContext<Next, NextCtx>\n\nfunction pipe<A, Z>(\n  ab: (i: A, c: Ctx) => Z\n): (input: A, ctx: Ctx) => EnsurePromise<Z>\nfunction pipe<A, B, C, CA = Ctx, CB = CA, CC = CB>(\n  ab: PipeFn<A, B, CA, CB>,\n  bc: PipeFn<B, C, CB, CC>\n): (input: A, ctx: CA) => EnsurePromise<C>\nfunction pipe<A, B, C, D, CA = Ctx, CB = CA, CC = CB, CD = CC>(\n  ab: PipeFn<A, B, CA, CB>,\n  bc: PipeFn<B, C, CB, CC>,\n  cd: PipeFn<C, D, CC, CD>\n): (input: A, ctx: CA) => EnsurePromise<D>\nfunction pipe<A, B, C, D, E, CA = Ctx, CB = CA, CC = CB, CD = CC, CE = CD>(\n  ab: PipeFn<A, B, CA, CB>,\n  bc: PipeFn<B, C, CB, CC>,\n  cd: PipeFn<C, D, CC, CD>,\n  de: PipeFn<D, E, CD, CE>\n): (input: A, ctx: CA) => EnsurePromise<E>\nfunction pipe<\n  A,\n  B,\n  C,\n  D,\n  E,\n  F,\n  CA = Ctx,\n  CB = CA,\n  CC = CB,\n  CD = CC,\n  CE = CD,\n  CF = CE\n>(\n  ab: PipeFn<A, B, CA, CB>,\n  bc: PipeFn<B, C, CB, CC>,\n  cd: PipeFn<C, D, CC, CD>,\n  de: PipeFn<D, E, CD, CE>,\n  ef: PipeFn<E, F, CE, CF>\n): (input: A, ctx: CA) => EnsurePromise<F>\nfunction pipe<\n  A,\n  B,\n  C,\n  D,\n  E,\n  F,\n  G,\n  CA = Ctx,\n  CB = CA,\n  CC = CB,\n  CD = CC,\n  CE = CD,\n  CF = CE,\n  CG = CF\n>(\n  ab: PipeFn<A, B, CA, CB>,\n  bc: PipeFn<B, C, CB, CC>,\n  cd: PipeFn<C, D, CC, CD>,\n  de: PipeFn<D, E, CD, CE>,\n  ef: PipeFn<E, F, CE, CF>,\n  fg: PipeFn<F, G, CF, CG>\n): (input: A, ctx: CA) => EnsurePromise<CG>\nfunction pipe<\n  A,\n  B,\n  C,\n  D,\n  E,\n  F,\n  G,\n  H,\n  CA = Ctx,\n  CB = CA,\n  CC = CB,\n  CD = CC,\n  CE = CD,\n  CF = CE,\n  CG = CF,\n  CH = CG\n>(\n  ab: PipeFn<A, B, CA, CB>,\n  bc: PipeFn<B, C, CB, CC>,\n  cd: PipeFn<C, D, CC, CD>,\n  de: PipeFn<D, E, CD, CE>,\n  ef: PipeFn<E, F, CE, CF>,\n  fg: PipeFn<F, G, CF, CG>,\n  gh: PipeFn<G, H, CG, CH>\n): (input: A, ctx: CA) => EnsurePromise<H>\nfunction pipe<\n  A,\n  B,\n  C,\n  D,\n  E,\n  F,\n  G,\n  H,\n  I,\n  CA = Ctx,\n  CB = CA,\n  CC = CB,\n  CD = CC,\n  CE = CD,\n  CF = CE,\n  CG = CF,\n  CH = CG,\n  CI = CH\n>(\n  ab: PipeFn<A, B, CA, CB>,\n  bc: PipeFn<B, C, CB, CC>,\n  cd: PipeFn<C, D, CC, CD>,\n  de: PipeFn<D, E, CD, CE>,\n  ef: PipeFn<E, F, CE, CF>,\n  fg: PipeFn<F, G, CF, CG>,\n  gh: PipeFn<G, H, CG, CH>,\n  hi: PipeFn<H, I, CH, CI>\n): (input: A, ctx: CA) => EnsurePromise<I>\nfunction pipe<\n  A,\n  B,\n  C,\n  D,\n  E,\n  F,\n  G,\n  H,\n  I,\n  J,\n  CA = Ctx,\n  CB = CA,\n  CC = CB,\n  CD = CC,\n  CE = CD,\n  CF = CE,\n  CG = CF,\n  CH = CG,\n  CI = CH,\n  CJ = CI\n>(\n  ab: PipeFn<A, B, CA, CB>,\n  bc: PipeFn<B, C, CB, CC>,\n  cd: PipeFn<C, D, CC, CD>,\n  de: PipeFn<D, E, CD, CE>,\n  ef: PipeFn<E, F, CE, CF>,\n  fg: PipeFn<F, G, CF, CG>,\n  gh: PipeFn<G, H, CG, CH>,\n  hi: PipeFn<H, I, CH, CI>,\n  ij: PipeFn<I, J, CI, CJ>\n): (input: A, ctx: CA) => EnsurePromise<J>\nfunction pipe<\n  A,\n  B,\n  C,\n  D,\n  E,\n  F,\n  G,\n  H,\n  I,\n  J,\n  K,\n  CA = Ctx,\n  CB = CA,\n  CC = CB,\n  CD = CC,\n  CE = CD,\n  CF = CE,\n  CG = CF,\n  CH = CG,\n  CI = CH,\n  CJ = CI,\n  CK = CJ\n>(\n  ab: PipeFn<A, B, CA, CB>,\n  bc: PipeFn<B, C, CB, CC>,\n  cd: PipeFn<C, D, CC, CD>,\n  de: PipeFn<D, E, CD, CE>,\n  ef: PipeFn<E, F, CE, CF>,\n  fg: PipeFn<F, G, CF, CG>,\n  gh: PipeFn<G, H, CG, CH>,\n  hi: PipeFn<H, I, CH, CI>,\n  ij: PipeFn<I, J, CI, CJ>,\n  jk: PipeFn<J, K, CJ, CK>\n): (input: A, ctx: CA) => EnsurePromise<K>\nfunction pipe<\n  A,\n  B,\n  C,\n  D,\n  E,\n  F,\n  G,\n  H,\n  I,\n  J,\n  K,\n  L,\n  CA = Ctx,\n  CB = CA,\n  CC = CB,\n  CD = CC,\n  CE = CD,\n  CF = CE,\n  CG = CF,\n  CH = CG,\n  CI = CH,\n  CJ = CI,\n  CK = CJ,\n  CL = CK\n>(\n  ab: PipeFn<A, B, CA, CB>,\n  bc: PipeFn<B, C, CB, CC>,\n  cd: PipeFn<C, D, CC, CD>,\n  de: PipeFn<D, E, CD, CE>,\n  ef: PipeFn<E, F, CE, CF>,\n  fg: PipeFn<F, G, CF, CG>,\n  gh: PipeFn<G, H, CG, CH>,\n  hi: PipeFn<H, I, CH, CI>,\n  ij: PipeFn<I, J, CI, CJ>,\n  jk: PipeFn<J, K, CJ, CK>,\n  kl: PipeFn<K, L, CK, CL>\n): (input: A, ctx: CA) => EnsurePromise<L>\nfunction pipe<\n  A,\n  B,\n  C,\n  D,\n  E,\n  F,\n  G,\n  H,\n  I,\n  J,\n  K,\n  L,\n  M,\n  CA = Ctx,\n  CB = CA,\n  CC = CB,\n  CD = CC,\n  CE = CD,\n  CF = CE,\n  CG = CF,\n  CH = CG,\n  CI = CH,\n  CJ = CI,\n  CK = CJ,\n  CL = CK,\n  CM = CL\n>(\n  ab: PipeFn<A, B, CA, CB>,\n  bc: PipeFn<B, C, CB, CC>,\n  cd: PipeFn<C, D, CC, CD>,\n  de: PipeFn<D, E, CD, CE>,\n  ef: PipeFn<E, F, CE, CF>,\n  fg: PipeFn<F, G, CF, CG>,\n  gh: PipeFn<G, H, CG, CH>,\n  hi: PipeFn<H, I, CH, CI>,\n  ij: PipeFn<I, J, CI, CJ>,\n  jk: PipeFn<J, K, CJ, CK>,\n  kl: PipeFn<K, L, CK, CL>,\n  lm: PipeFn<L, M, CL, CM>\n): (input: A, ctx: CA) => EnsurePromise<M>\nfunction pipe(...args: unknown[]): unknown {\n  const functions = args as PipeFn<unknown, unknown, Ctx>[]\n\n  return async function (input: unknown, ctx: Ctx) {\n    let lastResult = input\n    for (let fn of functions) {\n      lastResult = await fn(lastResult, ctx)\n      if (isResultWithContext(lastResult)) {\n        ctx = lastResult.ctx as Ctx\n        lastResult = lastResult.value\n      }\n    }\n    return lastResult\n  }\n}\n\ninterface ResolverAuthorize {\n  <T, C = Ctx>(...args: Parameters<SessionContextBase['$authorize']>): (\n    input: T,\n    ctx: C\n  ) => ResultWithContext<T, AuthenticatedMiddlewareCtx>\n}\n\nconst authorize: ResolverAuthorize = (...args) => {\n  return function _innerAuthorize(input, ctx) {\n    const session: SessionContext = (ctx as any).session\n    session.$authorize(...args)\n    return {\n      __blitz: true,\n      value: input,\n      // we could use {...ctx, session} instead of `as any` just for TypeScript's sake\n      ctx: ctx as any,\n    }\n  }\n}\n\nfunction zod<\n  Schema extends ZodTypeAny,\n  InputType = zInput<Schema>,\n  OutputType = zOutput<Schema>\n>(schema: Schema, parserType: 'sync'): (input: InputType) => OutputType\nfunction zod<\n  Schema extends ZodTypeAny,\n  InputType = zInput<Schema>,\n  OutputType = zOutput<Schema>\n>(\n  schema: Schema,\n  parserType: 'async'\n): (input: InputType) => Promise<OutputType>\nfunction zod<\n  Schema extends ZodTypeAny,\n  InputType = zInput<Schema>,\n  OutputType = zOutput<Schema>\n>(schema: Schema): (input: InputType) => Promise<OutputType>\nfunction zod<\n  Schema extends ZodTypeAny,\n  InputType = zInput<Schema>,\n  OutputType = zOutput<Schema>\n>(schema: Schema, parserType: ParserType = 'async') {\n  if (parserType === 'sync') {\n    return (input: InputType): OutputType => schema.parse(input)\n  } else {\n    return (input: InputType): Promise<OutputType> => schema.parseAsync(input)\n  }\n}\n\nexport const resolver = {\n  pipe,\n  zod,\n  authorize,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SAeS,mBAAmB,CAAC,CAAU,EAA0B,CAAC;kBAEvD,CAAC,MAAK,MAAQ,KACrB,CAAC,KAAK,IAAI,KACV,GAAK,KAAI,CAAC,IACT,CAAC,CAAuB,OAAO,KAAK,IAAI;AAE7C,CAAC;SAmRQ,IAAI,IAAI,IAAI,EAAsB,CAAC;IAC1C,KAAK,CAAC,SAAS,GAAG,IAAI;qBAEC,KAAc,EAAE,GAAQ;+CAAxB,KAAc,EAAE,GAAQ,EAAE,CAAC;YAChD,GAAG,CAAC,UAAU,GAAG,KAAK;iBACjB,GAAG,CAAC,EAAE,IAAI,SAAS,CAAE,CAAC;gBACzB,UAAU,SAAS,EAAE,CAAC,UAAU,EAAE,GAAG;gBACrC,EAAE,EAAE,mBAAmB,CAAC,UAAU,GAAG,CAAC;oBACpC,GAAG,GAAG,UAAU,CAAC,GAAG;oBACpB,UAAU,GAAG,UAAU,CAAC,KAAK;gBAC/B,CAAC;YACH,CAAC;mBACM,UAAU;QACnB,CAAC;;;;;AACH,CAAC;AASD,KAAK,CAAC,SAAS,OAA0B,IAAI,GAAK,CAAC;oBACjC,eAAe,CAAC,KAAK,EAAE,GAAG,EAAE,CAAC;QAC3C,KAAK,CAAC,OAAO,GAAoB,GAAG,CAAS,OAAO;QACpD,OAAO,CAAC,UAAU,IAAI,IAAI;;YAExB,OAAO,EAAE,IAAI;YACb,KAAK,EAAE,KAAK;YACZ,EAAgF,AAAhF,8EAAgF;YAChF,GAAG,EAAE,GAAG;;IAEZ,CAAC;AACH,CAAC;SAoBQ,GAAG,CAIV,MAAc,EAAE,UAAsB,IAAG,KAAO,GAAE,CAAC;IACnD,EAAE,EAAE,UAAU,MAAK,IAAM,GAAE,CAAC;gBAClB,KAAgB,GAAiB,MAAM,CAAC,KAAK,CAAC,KAAK;;IAC7D,CAAC,MAAM,CAAC;gBACE,KAAgB,GAA0B,MAAM,CAAC,UAAU,CAAC,KAAK;;IAC3E,CAAC;AACH,CAAC;AAEM,KAAK,CAAC,QAAQ;IACnB,IAAI;IACJ,GAAG;IACH,SAAS;;QAHE,QAAQ,GAAR,QAAQ"}