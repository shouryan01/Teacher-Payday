{"version":3,"sources":["../../stdlib-server/index.ts"],"sourcesContent":["import { IncomingMessage } from 'http'\nimport { NextApiRequest } from '../shared/lib/utils'\nimport { PaginationArgumentError } from '../stdlib/errors'\n\nexport * from './middleware'\nexport * from './auth-sessions'\nexport * from './auth-utils'\nexport * from './passport-adapter'\nexport * from './resolver'\n\nexport function isLocalhost(req: NextApiRequest | IncomingMessage): boolean {\n  let { host } = req.headers\n  let localhost = false\n  if (host) {\n    host = host.split(':')[0]\n    localhost = host === 'localhost'\n  }\n  return localhost\n}\n\nexport type PaginateArgs<QueryResult> = {\n  skip?: number\n  take?: number\n  maxTake?: number\n  count: () => Promise<number>\n  query: (args: { skip: number; take: number }) => Promise<QueryResult>\n}\n\nconst isInteger = (value: unknown) =>\n  typeof value === 'number' && value % 1 === 0\n\nexport async function paginate<QueryResult>({\n  skip = 0,\n  take = 0,\n  maxTake = 250,\n  count: countQuery,\n  query,\n}: PaginateArgs<QueryResult>) {\n  if (!isInteger(skip)) {\n    throw new PaginationArgumentError('`skip` argument must be a integer')\n  }\n  if (!isInteger(take)) {\n    throw new PaginationArgumentError('`take` argument must be a integer')\n  }\n  if (!isInteger(maxTake)) {\n    throw new PaginationArgumentError('`maxTake` argument must be a integer')\n  }\n  if (typeof countQuery !== 'function') {\n    throw new PaginationArgumentError('`count` argument must be a function')\n  }\n  if (typeof query !== 'function') {\n    throw new PaginationArgumentError('`query` argument must be a function')\n  }\n  if (skip < 0) {\n    throw new PaginationArgumentError(\n      '`skip` argument must be a positive number'\n    )\n  }\n  if (take < 0) {\n    throw new PaginationArgumentError(\n      '`take` argument must be a positive number'\n    )\n  }\n  if (take > maxTake) {\n    throw new PaginationArgumentError(\n      '`take` argument must less than `maxTake` which is currently ' + maxTake\n    )\n  }\n\n  const [count, items] = await Promise.all([\n    countQuery(),\n    query({ skip, take }),\n  ])\n\n  const hasMore = skip + take < count\n  const nextPage = hasMore ? { take, skip: skip + take } : null\n\n  return {\n    items,\n    nextPage,\n    hasMore,\n    count,\n  }\n}\n"],"names":[],"mappings":";;;;QAUgB,WAAW,GAAX,WAAW;QAqBL,QAAQ,GAAR,QAAQ;;;AA7BU,GAAkB,CAAlB,OAAkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SAQ1C,WAAW,CAAC,GAAqC,EAAW,CAAC;IAC3E,GAAG,GAAG,IAAI,MAAK,GAAG,CAAC,OAAO;IAC1B,GAAG,CAAC,SAAS,GAAG,KAAK;IACrB,EAAE,EAAE,IAAI,EAAE,CAAC;QACT,IAAI,GAAG,IAAI,CAAC,KAAK,EAAC,CAAG,GAAE,CAAC;QACxB,SAAS,GAAG,IAAI,MAAK,SAAW;IAClC,CAAC;WACM,SAAS;AAClB,CAAC;AAUD,KAAK,CAAC,SAAS,IAAI,KAAc,UACxB,KAAK,MAAK,MAAQ,KAAI,KAAK,GAAG,CAAC,KAAK,CAAC;;SAExB,SAAQ;IAAR,SAAQ,iCAC5B,IAAI,EAAG,CAAC,GACR,IAAI,EAAG,CAAC,GACR,OAAO,EAAG,GAAG,GACb,KAAK,EAAE,UAAU,GACjB,KAAK,KACuB,CAAC;QAC7B,EAAE,GAAG,SAAS,CAAC,IAAI,GAAG,CAAC;YACrB,KAAK,CAAC,GAAG,CArC2B,OAAkB,0BAqCpB,iCAAmC;QACvE,CAAC;QACD,EAAE,GAAG,SAAS,CAAC,IAAI,GAAG,CAAC;YACrB,KAAK,CAAC,GAAG,CAxC2B,OAAkB,0BAwCpB,iCAAmC;QACvE,CAAC;QACD,EAAE,GAAG,SAAS,CAAC,OAAO,GAAG,CAAC;YACxB,KAAK,CAAC,GAAG,CA3C2B,OAAkB,0BA2CpB,oCAAsC;QAC1E,CAAC;QACD,EAAE,SAAS,UAAU,MAAK,QAAU,GAAE,CAAC;YACrC,KAAK,CAAC,GAAG,CA9C2B,OAAkB,0BA8CpB,mCAAqC;QACzE,CAAC;QACD,EAAE,SAAS,KAAK,MAAK,QAAU,GAAE,CAAC;YAChC,KAAK,CAAC,GAAG,CAjD2B,OAAkB,0BAiDpB,mCAAqC;QACzE,CAAC;QACD,EAAE,EAAE,IAAI,GAAG,CAAC,EAAE,CAAC;YACb,KAAK,CAAC,GAAG,CApD2B,OAAkB,0BAqDpD,yCAA2C;QAE/C,CAAC;QACD,EAAE,EAAE,IAAI,GAAG,CAAC,EAAE,CAAC;YACb,KAAK,CAAC,GAAG,CAzD2B,OAAkB,0BA0DpD,yCAA2C;QAE/C,CAAC;QACD,EAAE,EAAE,IAAI,GAAG,OAAO,EAAE,CAAC;YACnB,KAAK,CAAC,GAAG,CA9D2B,OAAkB,0BA+DpD,4DAA8D,IAAG,OAAO;QAE5E,CAAC;QAED,KAAK,EAAE,KAAK,EAAE,KAAK,UAAU,OAAO,CAAC,GAAG;YACtC,UAAU;YACV,KAAK;gBAAG,IAAI;gBAAE,IAAI;;;QAGpB,KAAK,CAAC,OAAO,GAAG,IAAI,GAAG,IAAI,GAAG,KAAK;QACnC,KAAK,CAAC,QAAQ,GAAG,OAAO;YAAK,IAAI;YAAE,IAAI,EAAE,IAAI,GAAG,IAAI;YAAK,IAAI;;YAG3D,KAAK;YACL,QAAQ;YACR,OAAO;YACP,KAAK;;IAET,CAAC;WApDqB,SAAQ;;SAAR,QAAQ;WAAR,SAAQ"}