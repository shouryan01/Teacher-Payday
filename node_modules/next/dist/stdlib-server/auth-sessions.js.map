{"version":3,"sources":["../../stdlib-server/auth-sessions.ts"],"sourcesContent":["import { baseLogger } from '../server/lib/logging'\nimport { fromBase64, toBase64 } from 'b64-lite'\nimport cookie from 'next/dist/compiled/cookie'\nimport fs from 'fs'\nimport { IncomingMessage, ServerResponse } from 'http'\nimport { join } from 'path'\nimport {\n  sign as jwtSign,\n  verify as jwtVerify,\n} from 'next/dist/compiled/jsonwebtoken'\nimport { getCookieParser } from '../server/api-utils'\nimport {\n  AuthenticationError,\n  AuthorizationError,\n  CSRFTokenMismatchError,\n  addMinutes,\n  addYears,\n  differenceInMinutes,\n  isPast,\n} from '../stdlib/index'\nimport { isLocalhost } from './index'\nimport {\n  EmptyPublicData,\n  IsAuthorizedArgs,\n  PublicData,\n  SessionConfig,\n  SessionContext,\n  NextApiRequest,\n  NextApiResponse,\n  Ctx,\n  Middleware,\n  MiddlewareResponse,\n} from '../shared/lib/utils'\nimport {\n  COOKIE_ANONYMOUS_SESSION_TOKEN,\n  COOKIE_CSRF_TOKEN,\n  COOKIE_PUBLIC_DATA_TOKEN,\n  COOKIE_REFRESH_TOKEN,\n  COOKIE_SESSION_TOKEN,\n  HANDLE_SEPARATOR,\n  HEADER_CSRF,\n  HEADER_CSRF_ERROR,\n  HEADER_PUBLIC_DATA_TOKEN,\n  HEADER_SESSION_CREATED,\n  SESSION_TOKEN_VERSION_0,\n  SESSION_TYPE_ANONYMOUS_JWT,\n  SESSION_TYPE_OPAQUE_TOKEN_SIMPLE,\n  TOKEN_SEPARATOR,\n} from '../data-client/constants'\nimport { generateToken, hash256 } from './auth-utils'\nconst debug = require('debug')('blitz:session')\n\nfunction assert(condition: any, message: string): asserts condition {\n  if (!condition) throw new Error(message)\n}\n\nconst getDb = () => {\n  if (!process.env.BLITZ_APP_DIR) {\n    throw new Error(\n      'Internal Blitz Error: process.env.BLITZ_APP_DIR is not set'\n    )\n  }\n  const projectRoot = process.env.BLITZ_APP_DIR\n  let path = join(projectRoot, '.next/server/blitz-db.js')\n  if (!fs.existsSync(path)) {\n    path = join(projectRoot, '.next/serverless/blitz-db.js')\n  }\n  // eslint-disable-next-line no-eval -- block webpack from following this module path\n  return eval('require')(path).default\n}\n\nconst defaultConfig: SessionConfig = {\n  sessionExpiryMinutes: 30 * 24 * 60, // Sessions expire after 30 days of being idle\n  method: 'essential',\n  sameSite: 'lax',\n  publicDataKeysToSyncAcrossSessions: ['role', 'roles'],\n  secureCookies:\n    !process.env.DISABLE_SECURE_COOKIES &&\n    process.env.NODE_ENV === 'production',\n  getSession: (handle) => getDb().session.findFirst({ where: { handle } }),\n  getSessions: (userId) => getDb().session.findMany({ where: { userId } }),\n  createSession: (session) => {\n    let user\n    if (session.userId) {\n      user = { connect: { id: session.userId } }\n    }\n    return getDb().session.create({\n      data: { ...session, userId: undefined, user },\n    })\n  },\n  updateSession: async (handle, session) => {\n    try {\n      return await getDb().session.update({ where: { handle }, data: session })\n    } catch (error) {\n      // Session doesn't exist in DB for some reason, so create it\n      if (error.code === 'P2016') {\n        baseLogger({ displayDateTime: false }).warn(\n          \"Could not update session because it's not in the DB\"\n        )\n      } else {\n        throw error\n      }\n    }\n  },\n  deleteSession: (handle) => getDb().session.delete({ where: { handle } }),\n  isAuthorized: () => {\n    throw new Error('No isAuthorized implementation provided')\n  },\n}\n\nexport interface SimpleRolesIsAuthorized<RoleType = string> {\n  ({\n    ctx,\n    args,\n  }: {\n    ctx: any\n    args: [roleOrRoles?: RoleType | RoleType[]]\n  }): boolean\n}\n\nexport const simpleRolesIsAuthorized: SimpleRolesIsAuthorized = ({\n  ctx,\n  args,\n}) => {\n  const [roleOrRoles] = args\n  const publicData = (ctx.session as SessionContext).$publicData as\n    | { roles: unknown }\n    | { role: unknown }\n\n  if ('role' in publicData && 'roles' in publicData) {\n    throw new Error(\n      \"Session publicData can only have only `role` or `roles`, but not both.'\"\n    )\n  }\n\n  let roles: string[] = []\n  if ('role' in publicData) {\n    if (typeof publicData.role !== 'string') {\n      throw new Error('Session publicData.role field must be a string')\n    }\n    roles.push(publicData.role)\n  } else if ('roles' in publicData) {\n    if (!Array.isArray(publicData.roles)) {\n      throw new Error(\n        'Session `publicData.roles` is not an array, but it must be'\n      )\n    }\n    roles = publicData.roles\n  } else {\n    throw new Error(\n      'Session publicData is missing the required `role` or roles` field'\n    )\n  }\n\n  // No roles required, so all roles allowed\n  if (!roleOrRoles) return true\n\n  const rolesToAuthorize: string[] = []\n  if (Array.isArray(roleOrRoles)) {\n    rolesToAuthorize.push(...roleOrRoles)\n  } else if (roleOrRoles) {\n    rolesToAuthorize.push(roleOrRoles)\n  }\n  for (const role of rolesToAuthorize) {\n    if (roles.includes(role)) return true\n  }\n  return false\n}\n\n// --------------------------------\n// Middleware\n// --------------------------------\nexport const sessionMiddleware = (\n  sessionConfig: Partial<SessionConfig> = {}\n): Middleware => {\n  assert(\n    sessionConfig.isAuthorized,\n    'You must provide an authorization implementation to sessionMiddleware as isAuthorized(userRoles, input)'\n  )\n\n  global.sessionConfig = {\n    ...defaultConfig,\n    ...sessionConfig,\n  }\n\n  // Checks if cookie prefix from configuration has\n  // non-alphanumeric characters and throws error\n  const cookiePrefix = global.sessionConfig.cookiePrefix ?? 'blitz'\n  assert(\n    cookiePrefix.match(/^[a-zA-Z0-9-_]+$/),\n    `The cookie prefix used has invalid characters. Only alphanumeric characters, \"-\"  and \"_\" character are supported`\n  )\n\n  const blitzSessionMiddleware: Middleware = async (req, res, next) => {\n    debug('Starting sessionMiddleware...')\n    if (!(res.blitzCtx as any).session) {\n      // This function also saves session to res.blitzCtx\n      await getSession(req, res)\n    }\n    return next()\n  }\n\n  blitzSessionMiddleware.config = {\n    name: 'blitzSessionMiddleware',\n    cookiePrefix,\n  }\n  return blitzSessionMiddleware\n}\n\ntype JwtPayload = AnonymousSessionPayload | null\ntype AnonSessionKernel = {\n  handle: string\n  publicData: EmptyPublicData\n  jwtPayload: JwtPayload\n  antiCSRFToken: string\n  anonymousSessionToken: string\n}\ntype AuthedSessionKernel = {\n  handle: string\n  publicData: PublicData\n  jwtPayload: JwtPayload\n  antiCSRFToken: string\n  sessionToken: string\n}\ntype SessionKernel = AnonSessionKernel | AuthedSessionKernel\n\n// const isNextApiRequest = (req: NextApiRequest | IncomingMessage): req is NextApiRequest => {\n//   return \"cookies\" in req\n// }\nfunction ensureNextApiRequest(\n  req: NextApiRequest | IncomingMessage\n): asserts req is NextApiRequest {\n  if (!('cookies' in req)) {\n    // Cookie parser isn't include inside getServerSideProps, so we have to add it\n    ;(req as NextApiRequest).cookies = getCookieParser(req.headers)()\n  }\n}\n// const isMiddlewareApResponse = (\n//   res: MiddlewareResponse | ServerResponse,\n// ): res is MiddlewareResponse => {\n//   return \"blitzCtx\" in res\n// }\nfunction ensureMiddlewareResponse(\n  res: NextApiResponse | ServerResponse\n): asserts res is MiddlewareResponse {\n  if (!('blitzCtx' in res)) {\n    ;(res as MiddlewareResponse).blitzCtx = {} as Ctx\n  }\n}\n\nexport async function getSession(\n  req: NextApiRequest | IncomingMessage,\n  res: NextApiResponse | ServerResponse\n): Promise<SessionContext> {\n  ensureNextApiRequest(req)\n  ensureMiddlewareResponse(res)\n\n  debug('cookiePrefix', process.env.__BLITZ_SESSION_COOKIE_PREFIX)\n\n  let response = res as MiddlewareResponse<{ session?: SessionContext }>\n\n  if (response.blitzCtx.session) {\n    return response.blitzCtx.session\n  }\n\n  let sessionKernel = await getSessionKernel(req, res)\n\n  if (sessionKernel) {\n    debug('Got existing session', sessionKernel)\n  }\n\n  if (!sessionKernel) {\n    debug('No session found, creating anonymous session')\n    sessionKernel = await createAnonymousSession(req, res)\n  }\n\n  const sessionContext = makeProxyToPublicData(\n    new SessionContextClass(req, res, sessionKernel)\n  )\n  response.blitzCtx.session = sessionContext\n  return sessionContext\n}\n\nconst makeProxyToPublicData = <T extends SessionContextClass>(\n  ctxClass: T\n): T => {\n  return new Proxy(ctxClass, {\n    get(target, prop, receiver) {\n      if (prop in target || prop === 'then') {\n        return Reflect.get(target, prop, receiver)\n      } else {\n        return Reflect.get(target.$publicData, prop, receiver)\n      }\n    },\n  })\n}\n\nexport class SessionContextClass implements SessionContext {\n  private _req: NextApiRequest\n  private _res: MiddlewareResponse\n  private _kernel: SessionKernel\n\n  constructor(\n    req: NextApiRequest,\n    res: MiddlewareResponse,\n    kernel: SessionKernel\n  ) {\n    this._req = req\n    this._res = res\n    this._kernel = kernel\n  }\n\n  get $handle() {\n    return this._kernel.handle\n  }\n  get userId() {\n    return this._kernel.publicData.userId\n  }\n  get $publicData() {\n    return this._kernel.publicData\n  }\n\n  $authorize(...args: IsAuthorizedArgs) {\n    const e = new AuthenticationError()\n    Error.captureStackTrace(e, this.$authorize)\n    if (!this.userId) throw e\n\n    if (!this.$isAuthorized(...args)) {\n      const err = new AuthorizationError()\n      Error.captureStackTrace(err, this.$authorize)\n      throw err\n    }\n  }\n\n  $isAuthorized(...args: IsAuthorizedArgs) {\n    if (!this.userId) return false\n\n    return global.sessionConfig.isAuthorized({ ctx: this._res.blitzCtx, args })\n  }\n\n  async $create(publicData: PublicData, privateData?: Record<any, any>) {\n    this._kernel = await createNewSession({\n      req: this._req,\n      res: this._res,\n      publicData,\n      privateData,\n      jwtPayload: this._kernel.jwtPayload,\n      anonymous: false,\n    })\n  }\n\n  async $revoke() {\n    this._kernel = await revokeSession(this._req, this._res, this.$handle)\n  }\n\n  async $revokeAll() {\n    // revoke the current session which uses req/res\n    await this.$revoke()\n    // revoke other sessions for which there is no req/res object\n    await revokeAllSessionsForUser(this.$publicData.userId)\n    return\n  }\n\n  async $setPublicData(data: Record<any, any>) {\n    if (this.userId) {\n      await syncPubicDataFieldsForUserIfNeeded(this.userId, data)\n    }\n    this._kernel.publicData = await setPublicData(\n      this._req,\n      this._res,\n      this._kernel,\n      data\n    )\n  }\n\n  async $getPrivateData() {\n    return (await getPrivateData(this.$handle)) || {}\n  }\n  $setPrivateData(data: Record<any, any>) {\n    return setPrivateData(this._kernel, data)\n  }\n}\n\n// --------------------------------\n// Token/handle utils\n// --------------------------------\nconst TOKEN_LENGTH = 32\n\nconst generateEssentialSessionHandle = () => {\n  return (\n    generateToken(TOKEN_LENGTH) +\n    HANDLE_SEPARATOR +\n    SESSION_TYPE_OPAQUE_TOKEN_SIMPLE\n  )\n}\n\nconst generateAnonymousSessionHandle = () => {\n  return (\n    generateToken(TOKEN_LENGTH) + HANDLE_SEPARATOR + SESSION_TYPE_ANONYMOUS_JWT\n  )\n}\n\nconst createSessionToken = (\n  handle: string,\n  publicData: PublicData | string\n) => {\n  // We store the hashed public data in the opaque token so that when we verify,\n  // we can detect changes in it and return a new set of tokens if necessary.\n\n  let publicDataString\n  if (typeof publicData === 'string') {\n    publicDataString = publicData\n  } else {\n    publicDataString = JSON.stringify(publicData)\n  }\n  return toBase64(\n    [\n      handle,\n      generateToken(TOKEN_LENGTH),\n      hash256(publicDataString),\n      SESSION_TOKEN_VERSION_0,\n    ].join(TOKEN_SEPARATOR)\n  )\n}\nconst parseSessionToken = (token: string) => {\n  const [handle, id, hashedPublicData, version] = fromBase64(token).split(\n    TOKEN_SEPARATOR\n  )\n\n  if (!handle || !id || !hashedPublicData || !version) {\n    throw new AuthenticationError('Failed to parse session token')\n  }\n\n  return {\n    handle,\n    id,\n    hashedPublicData,\n    version,\n  }\n}\n\nconst createPublicDataToken = (\n  publicData: string | PublicData | EmptyPublicData\n) => {\n  const payload =\n    typeof publicData === 'string' ? publicData : JSON.stringify(publicData)\n  return toBase64(payload)\n}\n\nconst createAntiCSRFToken = () => generateToken(TOKEN_LENGTH)\n\nexport type AnonymousSessionPayload = {\n  isAnonymous: true\n  handle: string\n  publicData: EmptyPublicData\n  antiCSRFToken: string\n}\n\nconst getSessionSecretKey = () => {\n  if (process.env.NODE_ENV === 'production') {\n    if (!process.env.SESSION_SECRET_KEY && process.env.SECRET_SESSION_KEY) {\n      throw new Error(\n        \"You need to rename the SECRET_SESSION_KEY environment variable to SESSION_SECRET_KEY (but don't feel bad, we've all done it :)\"\n      )\n    }\n    assert(\n      process.env.SESSION_SECRET_KEY,\n      'You must provide the SESSION_SECRET_KEY environment variable in production. This is used to sign and verify tokens. It should be 32 chars long.'\n    )\n    assert(\n      process.env.SESSION_SECRET_KEY.length >= 32,\n      'The SESSION_SECRET_KEY environment variable must be at least 32 bytes for sufficent token security'\n    )\n\n    return process.env.SESSION_SECRET_KEY\n  } else {\n    return process.env.SESSION_SECRET_KEY || 'default-dev-secret'\n  }\n}\n\nconst JWT_NAMESPACE = 'blitzjs'\nconst JWT_ISSUER = 'blitzjs'\nconst JWT_AUDIENCE = 'blitzjs'\nconst JWT_ANONYMOUS_SUBJECT = 'anonymous'\nconst JWT_ALGORITHM = 'HS256'\n\nconst createAnonymousSessionToken = (payload: AnonymousSessionPayload) => {\n  return jwtSign({ [JWT_NAMESPACE]: payload }, getSessionSecretKey(), {\n    algorithm: JWT_ALGORITHM,\n    issuer: JWT_ISSUER,\n    audience: JWT_AUDIENCE,\n    subject: JWT_ANONYMOUS_SUBJECT,\n  })\n}\n\nconst parseAnonymousSessionToken = (token: string) => {\n  // This must happen outside the try/catch because it could throw an error\n  // about a missing environment variable\n  const secret = getSessionSecretKey()\n\n  try {\n    const fullPayload = jwtVerify(token, secret, {\n      algorithms: [JWT_ALGORITHM],\n      issuer: JWT_ISSUER,\n      audience: JWT_AUDIENCE,\n      subject: JWT_ANONYMOUS_SUBJECT,\n    })\n\n    if (typeof fullPayload === 'object') {\n      return (fullPayload as any)[JWT_NAMESPACE] as AnonymousSessionPayload\n    } else {\n      return null\n    }\n  } catch (error) {\n    return null\n  }\n}\n\nconst setCookie = (res: ServerResponse, cookieStr: string) => {\n  const getCookieName = (c: string) => c.split('=', 2)[0]\n  const appendCookie = () => append(res, 'Set-Cookie', cookieStr)\n\n  const cookiesHeader = res.getHeader('Set-Cookie')\n  const cookieName = getCookieName(cookieStr)\n\n  if (typeof cookiesHeader !== 'string' && !Array.isArray(cookiesHeader)) {\n    appendCookie()\n    return\n  }\n\n  if (typeof cookiesHeader === 'string') {\n    if (cookieName === getCookieName(cookiesHeader)) {\n      res.setHeader('Set-Cookie', cookieStr)\n    } else {\n      appendCookie()\n    }\n  } else {\n    for (let i = 0; i < cookiesHeader.length; i++) {\n      if (cookieName === getCookieName(cookiesHeader[i])) {\n        cookiesHeader[i] = cookieStr\n        res.setHeader('Set-Cookie', cookieStr)\n        return\n      }\n    }\n    appendCookie()\n  }\n}\n\nconst setHeader = (res: ServerResponse, name: string, value: string) => {\n  res.setHeader(name, value)\n  if ('_blitz' in res) {\n    ;(res as any)._blitz[name] = value\n  }\n}\n\nconst setSessionCookie = (\n  req: IncomingMessage,\n  res: ServerResponse,\n  sessionToken: string,\n  expiresAt: Date\n) => {\n  setCookie(\n    res,\n    cookie.serialize(COOKIE_SESSION_TOKEN(), sessionToken, {\n      path: '/',\n      httpOnly: true,\n      secure: global.sessionConfig.secureCookies && !isLocalhost(req),\n      sameSite: global.sessionConfig.sameSite,\n      domain: global.sessionConfig.domain,\n      expires: expiresAt,\n    })\n  )\n}\n\nconst setAnonymousSessionCookie = (\n  req: IncomingMessage,\n  res: ServerResponse,\n  token: string,\n  expiresAt: Date\n) => {\n  setCookie(\n    res,\n    cookie.serialize(COOKIE_ANONYMOUS_SESSION_TOKEN(), token, {\n      path: '/',\n      httpOnly: true,\n      secure: global.sessionConfig.secureCookies && !isLocalhost(req),\n      sameSite: global.sessionConfig.sameSite,\n      domain: global.sessionConfig.domain,\n      expires: expiresAt,\n    })\n  )\n}\n\nconst setCSRFCookie = (\n  req: IncomingMessage,\n  res: ServerResponse,\n  antiCSRFToken: string,\n  expiresAt: Date\n) => {\n  debug('setCSRFCookie', antiCSRFToken)\n  assert(\n    antiCSRFToken !== undefined,\n    'Internal error: antiCSRFToken is being set to undefined'\n  )\n  setCookie(\n    res,\n    cookie.serialize(COOKIE_CSRF_TOKEN(), antiCSRFToken, {\n      path: '/',\n      secure: global.sessionConfig.secureCookies && !isLocalhost(req),\n      sameSite: global.sessionConfig.sameSite,\n      domain: global.sessionConfig.domain,\n      expires: expiresAt,\n    })\n  )\n}\n\nconst setPublicDataCookie = (\n  req: IncomingMessage,\n  res: ServerResponse,\n  publicDataToken: string,\n  expiresAt: Date\n) => {\n  setHeader(res, HEADER_PUBLIC_DATA_TOKEN, 'updated')\n  setCookie(\n    res,\n    cookie.serialize(COOKIE_PUBLIC_DATA_TOKEN(), publicDataToken, {\n      path: '/',\n      secure: global.sessionConfig.secureCookies && !isLocalhost(req),\n      sameSite: global.sessionConfig.sameSite,\n      domain: global.sessionConfig.domain,\n      expires: expiresAt,\n    })\n  )\n}\n\n// --------------------------------\n// Get Session\n// --------------------------------\nasync function getSessionKernel(\n  req: NextApiRequest,\n  res: ServerResponse\n): Promise<SessionKernel | null> {\n  const anonymousSessionToken = req.cookies[COOKIE_ANONYMOUS_SESSION_TOKEN()]\n  const sessionToken = req.cookies[COOKIE_SESSION_TOKEN()] // for essential method\n  const idRefreshToken = req.cookies[COOKIE_REFRESH_TOKEN()] // for advanced method\n  const enableCsrfProtection =\n    req.method !== 'GET' &&\n    req.method !== 'OPTIONS' &&\n    req.method !== 'HEAD' &&\n    !process.env.DANGEROUSLY_DISABLE_CSRF_PROTECTION\n  const antiCSRFToken = req.headers[HEADER_CSRF] as string | undefined\n\n  if (sessionToken) {\n    debug('[getSessionKernel] Request has sessionToken')\n    const { handle, version, hashedPublicData } = parseSessionToken(\n      sessionToken\n    )\n\n    if (!handle) {\n      debug('No handle in sessionToken')\n      return null\n    }\n\n    if (version !== SESSION_TOKEN_VERSION_0) {\n      console.log(\n        new AuthenticationError(\n          'Session token version is not ' + SESSION_TOKEN_VERSION_0\n        )\n      )\n      return null\n    }\n    debug('global session config', global.sessionConfig)\n    const persistedSession = await global.sessionConfig.getSession(handle)\n    if (!persistedSession) {\n      debug('Session not found in DB')\n      return null\n    }\n    if (!persistedSession.antiCSRFToken) {\n      throw new Error('Internal error: persistedSession.antiCSRFToken is empty')\n    }\n    if (persistedSession.hashedSessionToken !== hash256(sessionToken)) {\n      debug('sessionToken hash did not match')\n      debug('persisted: ', persistedSession.hashedSessionToken)\n      debug('in req: ', hash256(sessionToken))\n      return null\n    }\n    if (persistedSession.expiresAt && isPast(persistedSession.expiresAt)) {\n      debug('Session expired')\n      return null\n    }\n    if (\n      enableCsrfProtection &&\n      persistedSession.antiCSRFToken !== antiCSRFToken\n    ) {\n      if (!antiCSRFToken) {\n        baseLogger({ displayDateTime: false }).warn(\n          `This request is missing the ${HEADER_CSRF} header. You can learn about adding this here: https://blitzjs.com/docs/session-management#manual-api-requests`\n        )\n      }\n\n      setHeader(res, HEADER_CSRF_ERROR, 'true')\n      throw new CSRFTokenMismatchError()\n    }\n\n    /*\n     * Session Renewal - Will renew if any of the following is true\n     * 1) publicData has changed\n     * 2) 1/4 of expiry time has elasped\n     *\n     *  But only renew with non-GET requests because a GET request could be from a\n     *  browser level navigation\n     */\n    if (req.method !== 'GET') {\n      // The publicData in the DB could have been updated since this client last made\n      // a request. If so, then we generate a new access token\n      const hasPublicDataChanged =\n        hash256(persistedSession.publicData ?? undefined) !== hashedPublicData\n      if (hasPublicDataChanged) {\n        debug('PublicData has changed since the last request')\n      }\n\n      // Check if > 1/4th of the expiry time has passed\n      // (since we are doing a rolling expiry window).\n      const hasQuarterExpiryTimePassed =\n        persistedSession.expiresAt &&\n        differenceInMinutes(persistedSession.expiresAt, new Date()) <\n          0.75 * (global.sessionConfig.sessionExpiryMinutes as number)\n\n      if (hasQuarterExpiryTimePassed) {\n        debug('quarter expiry time has passed')\n        debug('Persisted expire time', persistedSession.expiresAt)\n      }\n\n      if (hasPublicDataChanged || hasQuarterExpiryTimePassed) {\n        await refreshSession(\n          req,\n          res,\n          {\n            handle,\n            publicData: JSON.parse(persistedSession.publicData || ''),\n            jwtPayload: null,\n            antiCSRFToken: persistedSession.antiCSRFToken,\n            sessionToken,\n          },\n          { publicDataChanged: hasPublicDataChanged }\n        )\n      }\n    }\n\n    return {\n      handle,\n      publicData: JSON.parse(persistedSession.publicData || ''),\n      jwtPayload: null,\n      antiCSRFToken: persistedSession.antiCSRFToken,\n      sessionToken,\n    }\n  } else if (idRefreshToken) {\n    // TODO: advanced method\n    return null\n    // Important: check anonymousSessionToken token as the very last thing\n  } else if (anonymousSessionToken) {\n    debug('Request has anonymousSessionToken')\n    const payload = parseAnonymousSessionToken(anonymousSessionToken)\n\n    if (!payload) {\n      debug('Payload empty')\n      return null\n    }\n\n    if (enableCsrfProtection && payload.antiCSRFToken !== antiCSRFToken) {\n      if (!antiCSRFToken) {\n        baseLogger({ displayDateTime: false }).warn(\n          `This request is missing the ${HEADER_CSRF} header. You can learn about adding this here: https://blitzjs.com/docs/session-management#manual-api-requests`\n        )\n      }\n\n      setHeader(res, HEADER_CSRF_ERROR, 'true')\n      throw new CSRFTokenMismatchError()\n    }\n\n    return {\n      handle: payload.handle,\n      publicData: payload.publicData,\n      antiCSRFToken: payload.antiCSRFToken,\n      jwtPayload: payload,\n      anonymousSessionToken,\n    }\n  }\n\n  // No session exists\n  return null\n}\n\n// --------------------------------\n// Create Session\n// --------------------------------\ninterface CreateNewAnonSession {\n  req: IncomingMessage\n  res: ServerResponse\n  publicData: EmptyPublicData\n  privateData?: Record<any, any>\n  anonymous: true\n  jwtPayload?: JwtPayload\n}\ninterface CreateNewAuthedSession {\n  req: IncomingMessage\n  res: ServerResponse\n  publicData: PublicData\n  privateData?: Record<any, any>\n  anonymous: false\n  jwtPayload?: JwtPayload\n}\n\nasync function createNewSession(\n  args: CreateNewAnonSession | CreateNewAuthedSession\n): Promise<SessionKernel> {\n  const { req, res } = args\n  assert(\n    args.publicData.userId !== undefined,\n    'You must provide publicData.userId'\n  )\n\n  const antiCSRFToken = createAntiCSRFToken()\n\n  if (args.anonymous) {\n    debug('Creating new anonymous session')\n    const handle = generateAnonymousSessionHandle()\n    const payload: AnonymousSessionPayload = {\n      isAnonymous: true,\n      handle,\n      publicData: args.publicData,\n      antiCSRFToken,\n    }\n    const anonymousSessionToken = createAnonymousSessionToken(payload)\n    const publicDataToken = createPublicDataToken(args.publicData)\n\n    const expiresAt = addYears(new Date(), 30)\n    setAnonymousSessionCookie(req, res, anonymousSessionToken, expiresAt)\n    setCSRFCookie(req, res, antiCSRFToken, expiresAt)\n    setPublicDataCookie(req, res, publicDataToken, expiresAt)\n    // Clear the essential session cookie in case it was previously set\n    setSessionCookie(req, res, '', new Date(0))\n    setHeader(res, HEADER_SESSION_CREATED, 'true')\n\n    return {\n      handle,\n      publicData: args.publicData,\n      jwtPayload: payload,\n      antiCSRFToken,\n      anonymousSessionToken,\n    }\n  } else if (global.sessionConfig.method === 'essential') {\n    debug('Creating new session')\n    const newPublicData: PublicData = {\n      // This carries over any public data from the anonymous session\n      ...(args.jwtPayload?.publicData || {}),\n      ...args.publicData,\n    }\n    assert(\n      newPublicData.userId,\n      'You must provide a non-empty userId as publicData.userId'\n    )\n\n    // This carries over any private data from the anonymous session\n    let existingPrivateData = {}\n    if (args.jwtPayload?.isAnonymous) {\n      const session = await global.sessionConfig.getSession(\n        args.jwtPayload.handle\n      )\n      if (session) {\n        if (session.privateData) {\n          existingPrivateData = JSON.parse(session.privateData)\n        }\n        // Delete the previous anonymous session\n        await global.sessionConfig.deleteSession(args.jwtPayload.handle)\n      }\n    }\n\n    const newPrivateData: Record<any, any> = {\n      ...existingPrivateData,\n      ...args.privateData,\n    }\n\n    const expiresAt = addMinutes(\n      new Date(),\n      global.sessionConfig.sessionExpiryMinutes as number\n    )\n    const handle = generateEssentialSessionHandle()\n    const sessionToken = createSessionToken(handle, newPublicData)\n    const publicDataToken = createPublicDataToken(newPublicData)\n\n    await global.sessionConfig.createSession({\n      expiresAt,\n      handle,\n      userId: newPublicData.userId,\n      hashedSessionToken: hash256(sessionToken),\n      antiCSRFToken,\n      publicData: JSON.stringify(newPublicData),\n      privateData: JSON.stringify(newPrivateData),\n    })\n\n    setSessionCookie(req, res, sessionToken, expiresAt)\n    setCSRFCookie(req, res, antiCSRFToken, expiresAt)\n    setPublicDataCookie(req, res, publicDataToken, expiresAt)\n    // Clear the anonymous session cookie in case it was previously set\n    setAnonymousSessionCookie(req, res, '', new Date(0))\n    setHeader(res, HEADER_SESSION_CREATED, 'true')\n\n    return {\n      handle,\n      publicData: newPublicData,\n      jwtPayload: null,\n      antiCSRFToken,\n      sessionToken,\n    }\n  } else if (global.sessionConfig.method === 'advanced') {\n    throw new Error('The advanced method is not yet supported')\n  } else {\n    throw new Error(\n      `Session management method ${global.sessionConfig.method} is invalid. Supported methods are \"essential\" and \"advanced\"`\n    )\n  }\n}\n\nasync function createAnonymousSession(\n  req: IncomingMessage,\n  res: ServerResponse\n) {\n  return await createNewSession({\n    req,\n    res,\n    publicData: { userId: null },\n    anonymous: true,\n  })\n}\n\n// --------------------------------\n// Session/DB utils\n// --------------------------------\n\nasync function refreshSession(\n  req: IncomingMessage,\n  res: ServerResponse,\n  sessionKernel: SessionKernel,\n  { publicDataChanged }: { publicDataChanged: boolean }\n) {\n  debug('Refreshing session', sessionKernel)\n  if (sessionKernel.jwtPayload?.isAnonymous) {\n    const payload: AnonymousSessionPayload = {\n      ...sessionKernel.jwtPayload,\n      publicData: sessionKernel.publicData,\n    }\n    const anonymousSessionToken = createAnonymousSessionToken(payload)\n    const publicDataToken = createPublicDataToken(sessionKernel.publicData)\n\n    const expiresAt = addYears(new Date(), 30)\n    setAnonymousSessionCookie(req, res, anonymousSessionToken, expiresAt)\n    setPublicDataCookie(req, res, publicDataToken, expiresAt)\n    setCSRFCookie(req, res, sessionKernel.antiCSRFToken, expiresAt)\n  } else if (\n    global.sessionConfig.method === 'essential' &&\n    'sessionToken' in sessionKernel\n  ) {\n    const expiresAt = addMinutes(\n      new Date(),\n      global.sessionConfig.sessionExpiryMinutes as number\n    )\n    const publicDataToken = createPublicDataToken(sessionKernel.publicData)\n\n    let sessionToken: string\n    // Only generate new session token if public data actually changed\n    // Otherwise if new session token is generated just for refresh, then\n    // we have race condition bugs\n    if (publicDataChanged) {\n      sessionToken = createSessionToken(\n        sessionKernel.handle,\n        sessionKernel.publicData\n      )\n    } else {\n      sessionToken = sessionKernel.sessionToken\n    }\n\n    setSessionCookie(req, res, sessionToken, expiresAt)\n    setPublicDataCookie(req, res, publicDataToken, expiresAt)\n    setCSRFCookie(req, res, sessionKernel.antiCSRFToken, expiresAt)\n\n    debug('Updating session in db with', { expiresAt })\n    if (publicDataChanged) {\n      await global.sessionConfig.updateSession(sessionKernel.handle, {\n        expiresAt,\n        hashedSessionToken: hash256(sessionToken),\n        publicData: JSON.stringify(sessionKernel.publicData),\n      })\n    } else {\n      await global.sessionConfig.updateSession(sessionKernel.handle, {\n        expiresAt,\n      })\n    }\n  } else if (global.sessionConfig.method === 'advanced') {\n    throw new Error('refreshSession() not implemented for advanced method')\n  }\n}\n\nexport async function getAllSessionHandlesForUser(\n  userId: PublicData['userId']\n) {\n  return (await global.sessionConfig.getSessions(userId)).map(\n    (session) => session.handle\n  )\n}\n\nasync function syncPubicDataFieldsForUserIfNeeded(\n  userId: PublicData['userId'],\n  data: Record<string, unknown>\n) {\n  const dataToSync: Record<string, unknown> = {}\n  global.sessionConfig.publicDataKeysToSyncAcrossSessions?.forEach((key) => {\n    if (data[key]) {\n      dataToSync[key] = data[key]\n    }\n  })\n  if (Object.keys(dataToSync).length) {\n    const sessions = await global.sessionConfig.getSessions(userId)\n\n    for (const session of sessions) {\n      const publicData = JSON.stringify({\n        ...(session.publicData ? JSON.parse(session.publicData) : {}),\n        ...dataToSync,\n      })\n      await global.sessionConfig.updateSession(session.handle, { publicData })\n    }\n  }\n}\n\nasync function revokeSession(\n  req: IncomingMessage,\n  res: ServerResponse,\n  handle: string,\n  anonymous: boolean = false\n) {\n  debug('Revoking session', handle)\n  if (!anonymous) {\n    try {\n      await global.sessionConfig.deleteSession(handle)\n    } catch (error) {\n      // Ignore any errors, like if session doesn't exist in DB\n    }\n  }\n  // Go ahead and create a new anon session. This\n  // This fixes race condition where all client side queries get refreshed\n  // in parallel and each creates a new anon session\n  // https://github.com/blitz-js/blitz/issues/2746\n  return createAnonymousSession(req, res)\n}\n\nasync function revokeAllSessionsForUser(userId: PublicData['userId']) {\n  let sessionHandles = (await global.sessionConfig.getSessions(userId)).map(\n    (session) => session.handle\n  )\n\n  let revoked: string[] = []\n  for (const handle of sessionHandles) {\n    try {\n      await global.sessionConfig.deleteSession(handle)\n    } catch (error) {\n      // Ignore any errors, like if session doesn't exist in DB\n    }\n    revoked.push(handle)\n  }\n  return revoked\n}\n\nasync function getPublicData(\n  sessionKernel: SessionKernel\n): Promise<PublicData | EmptyPublicData> {\n  if (sessionKernel.jwtPayload?.publicData) {\n    return sessionKernel.jwtPayload?.publicData\n  } else {\n    const session = await global.sessionConfig.getSession(sessionKernel.handle)\n    if (!session) {\n      throw new Error(\n        \"getPublicData() failed because handle doesn't exist \" +\n          sessionKernel.handle\n      )\n    }\n    if (session.publicData) {\n      return JSON.parse(session.publicData) as PublicData\n    } else {\n      return {} as PublicData\n    }\n  }\n}\n\nasync function getPrivateData(\n  handle: string\n): Promise<Record<any, any> | null> {\n  const session = await global.sessionConfig.getSession(handle)\n  if (session && session.privateData) {\n    return JSON.parse(session.privateData) as Record<any, any>\n  } else {\n    return null\n  }\n}\n\nasync function setPrivateData(\n  sessionKernel: SessionKernel,\n  data: Record<any, any>\n) {\n  let existingPrivateData = await getPrivateData(sessionKernel.handle)\n  if (existingPrivateData === null) {\n    // Anonymous sessions may not exist in the DB yet\n    try {\n      await global.sessionConfig.createSession({ handle: sessionKernel.handle })\n    } catch (error) {}\n    existingPrivateData = {}\n  }\n  const privateData = JSON.stringify({\n    ...existingPrivateData,\n    ...data,\n  })\n  await global.sessionConfig.updateSession(sessionKernel.handle, {\n    privateData,\n  })\n}\n\nasync function setPublicData(\n  req: IncomingMessage,\n  res: ServerResponse,\n  sessionKernel: SessionKernel,\n  data: Record<any, any>\n) {\n  // Don't allow updating userId\n  delete data.userId\n\n  const publicData = {\n    ...(await getPublicData(sessionKernel)),\n    ...data,\n  } as PublicData\n\n  await refreshSession(\n    req,\n    res,\n    { ...sessionKernel, publicData },\n    { publicDataChanged: true }\n  )\n  return publicData\n}\n\n/**\n * Updates publicData in all sessions\n *\n * @param {PublicData[\"userId\"]} userId\n * @param {Record<any, any>} data\n */\nexport async function setPublicDataForUser(\n  userId: PublicData['userId'],\n  data: Record<any, any>\n) {\n  // Don't allow updating userId\n  delete data.userId\n\n  const sessions = await global.sessionConfig.getSessions(userId)\n  for (const session of sessions) {\n    // Merge data\n    const publicData = JSON.stringify({\n      ...JSON.parse(session.publicData || ''),\n      ...data,\n    })\n\n    await global.sessionConfig.updateSession(session.handle, { publicData })\n  }\n}\n\n/**\n * Append additional header `field` with value `val`.\n *\n * Example:\n *\n *    append(res, 'Set-Cookie', 'foo=bar; Path=/; HttpOnly');\n *\n * @param {ServerResponse} res\n * @param {string} field\n * @param {string| string[]} val\n */\nfunction append(res: ServerResponse, field: string, val: string | string[]) {\n  let prev: string | string[] | undefined = res.getHeader(field) as\n    | string\n    | string[]\n    | undefined\n  let value = val\n\n  if (prev !== undefined) {\n    // concat the new and prev vals\n    value = Array.isArray(prev)\n      ? prev.concat(val)\n      : Array.isArray(val)\n      ? [prev].concat(val)\n      : [prev, val]\n  }\n\n  value = Array.isArray(value) ? value.map(String) : String(value)\n\n  res.setHeader(field, value)\n  return res\n}\n"],"names":[],"mappings":"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"}