"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.passportAuth = passportAuth;
var _logging = require("../server/lib/logging");
var _cookieSession = _interopRequireDefault(require("cookie-session"));
var _passport = _interopRequireDefault(require("passport"));
var _middleware = require("./middleware");
var _middleware1 = require("../server/middleware");
var _index = require("./index");
var _configShared = require("../server/config-shared");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {
        };
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}
function assert(condition, message) {
    if (!condition) throw new Error(message);
}
const isFunction = (functionToCheck)=>typeof functionToCheck === 'function'
;
const isVerifyCallbackResult = (value)=>typeof value === 'object' && value !== null && 'publicData' in value
;
const INTERNAL_REDIRECT_URL_KEY = '_redirectUrl';
function passportAuth(config) {
    return (function(req, res) {
        var _authHandler = _asyncToGenerator(function*(req, res) {
            const log = (0, _logging).baseLogger().getChildLogger();
            const appConfig = (0, _configShared).loadConfigAtRuntime();
            const globalMiddleware = (0, _middleware1).getAndValidateMiddleware(appConfig, {
            }, 'passport-adapter');
            yield (0, _middleware1).handleRequestWithMiddleware(req, res, globalMiddleware);
            const configObject = isFunction(config) ? config({
                ctx: res.blitzCtx,
                req,
                res
            }) : config;
            const cookieSessionMiddleware = (0, _cookieSession).default({
                secret: process.env.SESSION_SECRET_KEY || 'default-dev-secret',
                secure: process.env.NODE_ENV === 'production' && !(0, _index).isLocalhost(req)
            });
            const passportMiddleware = _passport.default.initialize();
            const middleware = [
                (0, _middleware).connectMiddleware(cookieSessionMiddleware),
                (0, _middleware).connectMiddleware(passportMiddleware),
                (0, _middleware).connectMiddleware(_passport.default.session()), 
            ];
            if (configObject.secureProxy) {
                middleware.push(_middleware.secureProxyMiddleware);
            }
            assert(req.query.auth, 'req.query.auth is not defined. Page must be named [...auth].ts/js. See more at https://blitzjs.com/docs/passportjs#1-add-the-passport-js-api-route');
            assert(Array.isArray(req.query.auth), 'req.query.auth must be an array. Page must be named [...auth].ts/js. See more at https://blitzjs.com/docs/passportjs#1-add-the-passport-js-api-route');
            if (!req.query.auth.length) {
                return res.status(404).end();
            }
            assert(configObject.strategies.length, 'No Passport strategies found! Please add at least one strategy.');
            const blitzStrategy = configObject.strategies.find(({ strategy  })=>strategy.name === req.query.auth[0]
            );
            assert(blitzStrategy, `A passport strategy was not found for: ${req.query.auth[0]}`);
            const { strategy , authenticateOptions  } = blitzStrategy;
            _passport.default.use(strategy);
            const strategyName = strategy.name;
            if (req.query.auth.length === 1) {
                log.info(`Starting authentication via ${strategyName}...`);
                console.info(`Starting authentication via ${strategyName}...`);
                if (req.query.redirectUrl) {
                    // eslint-disable-next-line no-shadow
                    middleware.push(_asyncToGenerator(function*(req1, res1, next) {
                        const session = res1.blitzCtx.session;
                        assert(session, 'Missing Blitz sessionMiddleware!');
                        yield session.$setPublicData({
                            [INTERNAL_REDIRECT_URL_KEY]: req1.query.redirectUrl
                        });
                        return next();
                    }));
                }
                middleware.push((0, _middleware).connectMiddleware(_passport.default.authenticate(strategyName, _objectSpread({
                }, authenticateOptions))));
            } else if (req.query.auth[1] === 'callback') {
                log.info(`Processing callback for ${strategyName}...`);
                console.info(`Processing callback for ${strategyName}...`);
                middleware.push(// eslint-disable-next-line no-shadow
                (0, _middleware).connectMiddleware((req1, res1, next)=>{
                    const session = res1.blitzCtx.session;
                    assert(session, 'Missing Blitz sessionMiddleware!');
                    _passport.default.authenticate(strategyName, _asyncToGenerator(function*(err, result) {
                        try {
                            let error = err;
                            if (!error && result === false) {
                                log.warn(`Login via ${strategyName} failed - usually this means the user did not authenticate properly with the provider`);
                                error = `Login failed`;
                            }
                            const redirectUrlFromVerifyResult = result && typeof result === 'object' && result.redirectUrl;
                            let redirectUrl = redirectUrlFromVerifyResult || session.$publicData[INTERNAL_REDIRECT_URL_KEY] || (error ? configObject.errorRedirectUrl : configObject.successRedirectUrl) || '/';
                            if (error) {
                                redirectUrl += '?authError=' + encodeURIComponent(error.toString());
                                res1.setHeader('Location', redirectUrl);
                                res1.statusCode = 302;
                                res1.end();
                                return;
                            }
                            assert(typeof result === 'object' && result !== null, `Your '${strategyName}' passport verify callback returned empty data. Ensure you call 'done(null, {publicData: {userId: 1}})' along with any other publicData fields you need)`);
                            assert(result.publicData, `'publicData' is missing from your '${strategyName}' passport verify callback. Ensure you call 'done(null, {publicData: {userId: 1}})' along with any other publicData fields you need)`);
                            assert(isVerifyCallbackResult(result), 'Passport verify callback is invalid');
                            delete result.publicData[INTERNAL_REDIRECT_URL_KEY];
                            yield session.$create(result.publicData, result.privateData);
                            res1.setHeader('Location', redirectUrl);
                            res1.statusCode = 302;
                            res1.end();
                        } catch (error1) {
                            console.error(error1);
                            res1.statusCode = 500;
                            res1.end();
                        }
                    }))(req1, res1, next);
                }));
            }
            yield (0, _middleware1).handleRequestWithMiddleware(req, res, middleware);
        });
        function authHandler() {
            return _authHandler.apply(this, arguments);
        }
        return authHandler;
    })();
}

//# sourceMappingURL=passport-adapter.js.map