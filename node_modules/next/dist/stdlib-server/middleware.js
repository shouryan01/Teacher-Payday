"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.invokeWithMiddleware = invokeWithMiddleware;
exports.connectMiddleware = connectMiddleware;
exports.secureProxyMiddleware = void 0;
var _middleware = require("../server/middleware");
var _utils = require("../server/lib/utils");
var _configShared = require("../server/config-shared");
var _chalk = _interopRequireDefault(require("chalk"));
var _loadComponents = require("../server/load-components");
var _logging = require("../server/lib/logging");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _invokeWithMiddleware() {
    _invokeWithMiddleware = _asyncToGenerator(function*(resolver, params, ctx) {
        var ref;
        if (!ctx.req) {
            throw new Error('You must provide `req` in third argument of invokeWithMiddleware()');
        }
        if (!ctx.res) {
            throw new Error('You must provide `res` in third argument of invokeWithMiddleware()');
        }
        const rpcResolver = resolver;
        var __resolverName;
        // can be .default._resolverName when user imports with `* as resolver`
        const resolverName = (__resolverName = rpcResolver._resolverName) !== null && __resolverName !== void 0 ? __resolverName : (ref = rpcResolver.default) === null || ref === void 0 ? void 0 : ref._resolverName;
        const config = (0, _configShared).loadConfigAtRuntime();
        const middleware = (0, _middleware).getAndValidateMiddleware(config, rpcResolver, resolverName);
        if (ctx.middleware) {
            middleware.push(...ctx.middleware);
        }
        middleware.push(_asyncToGenerator(function*(_req, res, next) {
            const log = (0, _logging).baseLogger().getChildLogger({
                prefix: [
                    resolverName + '()'
                ]
            });
            (0, _logging).newline();
            try {
                log.info(_chalk.default.dim('Starting with input:'), params);
                const startTime = Date.now();
                const result = yield (0, _loadComponents).interopDefault(rpcResolver)(params, res.blitzCtx);
                const duration = Date.now() - startTime;
                log.info(_chalk.default.dim(`Finished in ${(0, _utils).prettyMs(duration)}`));
                (0, _logging).newline();
                res.blitzResult = result;
                return next();
            } catch (error) {
                throw error;
            }
        }));
        yield (0, _middleware).handleRequestWithMiddleware(ctx.req, ctx.res, middleware);
        return ctx.res.blitzResult;
    });
    return _invokeWithMiddleware.apply(this, arguments);
}
function invokeWithMiddleware(resolver, params, ctx) {
    return _invokeWithMiddleware.apply(this, arguments);
}
/**
 * If the middleware function doesn't declare receiving the `next` callback
 * assume that it's synchronous and invoke `next` ourselves
 */ function noCallbackHandler(req, res, next, middleware) {
    middleware(req, res);
    return next();
}
/**
 * The middleware function does include the `next` callback so only resolve
 * the Promise when it's called. If it's never called, the middleware stack
 * completion will stall
 */ function withCallbackHandler(req, res, next, middleware) {
    return new Promise((resolve, reject)=>{
        // Rule doesn't matter since we are inside new Promise()
        //eslint-disable-next-line @typescript-eslint/no-floating-promises
        middleware(req, res, (err)=>{
            if (err) reject(err);
            else resolve(next());
        });
    });
}
function connectMiddleware(middleware) {
    const handler = middleware.length < 3 ? noCallbackHandler : withCallbackHandler;
    return function connectHandler(req, res, next) {
        return handler(req, res, next, middleware);
    };
}
const secureProxyMiddleware = function(req, _res, next) {
    req.protocol = 'https';
    next();
};
exports.secureProxyMiddleware = secureProxyMiddleware;

//# sourceMappingURL=middleware.js.map