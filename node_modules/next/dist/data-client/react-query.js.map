{"version":3,"sources":["../../data-client/react-query.tsx"],"sourcesContent":["import {\n  useInfiniteQuery as useInfiniteReactQuery,\n  UseInfiniteQueryOptions,\n  UseInfiniteQueryResult,\n  useQuery as useReactQuery,\n  UseQueryOptions,\n  UseQueryResult,\n  MutateOptions,\n  useMutation as useReactQueryMutation,\n  UseMutationOptions,\n  UseMutationResult,\n} from 'react-query'\nimport { useSession } from './auth'\nimport { FirstParam, PromiseReturnType, AsyncFunc } from '../types/utils'\nimport { isServer } from '../stdlib/index'\nimport {\n  emptyQueryFn,\n  getQueryCacheFunctions,\n  getQueryKey,\n  QueryCacheFunctions,\n  sanitizeQuery,\n  sanitizeMutation,\n  getInfiniteQueryKey,\n} from './react-query-utils'\nimport { useRouter } from '../client/router'\n\ntype QueryLazyOptions = { suspense: unknown } | { enabled: unknown }\ntype QueryNonLazyOptions =\n  | { suspense: true; enabled?: never }\n  | { suspense?: never; enabled: true }\n  | { suspense: true; enabled: true }\n  | { suspense?: never; enabled?: never }\n\n// -------------------------\n// useQuery\n// -------------------------\ntype RestQueryResult<TResult, TError> = Omit<\n  UseQueryResult<TResult, TError>,\n  'data'\n> &\n  QueryCacheFunctions<TResult>\n\nexport function useQuery<\n  T extends AsyncFunc,\n  TResult = PromiseReturnType<T>,\n  TError = unknown,\n  TSelectedData = TResult\n>(\n  queryFn: T,\n  params: FirstParam<T>,\n  options?: UseQueryOptions<TResult, TError, TSelectedData> &\n    QueryNonLazyOptions\n): [TSelectedData, RestQueryResult<TSelectedData, TError>]\nexport function useQuery<\n  T extends AsyncFunc,\n  TResult = PromiseReturnType<T>,\n  TError = unknown,\n  TSelectedData = TResult\n>(\n  queryFn: T,\n  params: FirstParam<T>,\n  options: UseQueryOptions<TResult, TError, TSelectedData> & QueryLazyOptions\n): [TSelectedData | undefined, RestQueryResult<TSelectedData, TError>]\nexport function useQuery<\n  T extends AsyncFunc,\n  TResult = PromiseReturnType<T>,\n  TError = unknown,\n  TSelectedData = TResult\n>(\n  queryFn: T,\n  params: FirstParam<T>,\n  options: UseQueryOptions<TResult, TError, TSelectedData> = {}\n) {\n  if (typeof queryFn === 'undefined') {\n    throw new Error(\n      'useQuery is missing the first argument - it must be a query function'\n    )\n  }\n\n  const suspenseEnabled = Boolean(process.env.__BLITZ_SUSPENSE_ENABLED)\n  let enabled =\n    isServer && suspenseEnabled\n      ? false\n      : options?.enabled ?? options?.enabled !== null\n  const suspense = enabled === false ? false : options?.suspense\n  const session = useSession({ suspense })\n  if (session.isLoading) {\n    enabled = false\n  }\n\n  const routerIsReady = useRouter().isReady || (isServer && suspenseEnabled)\n  const enhancedResolverRpcClient = sanitizeQuery(queryFn)\n  const queryKey = getQueryKey(queryFn, params)\n\n  const { data, ...queryRest } = useReactQuery({\n    queryKey: routerIsReady ? queryKey : ['_routerNotReady_'],\n    queryFn: routerIsReady\n      ? () => enhancedResolverRpcClient(params, { fromQueryHook: true })\n      : (emptyQueryFn as any),\n    ...options,\n    enabled,\n  })\n\n  if (\n    queryRest.isIdle &&\n    isServer &&\n    suspenseEnabled !== false &&\n    !data &&\n    (!options || !('suspense' in options) || options.suspense) &&\n    (!options || !('enabled' in options) || options.enabled)\n  ) {\n    throw new Promise(() => {})\n  }\n\n  const rest = {\n    ...queryRest,\n    ...getQueryCacheFunctions<FirstParam<T>, TResult, T>(queryFn, params),\n  }\n\n  // return [data, rest as RestQueryResult<TResult>]\n  return [data, rest]\n}\n\n// -------------------------\n// usePaginatedQuery\n// -------------------------\ntype RestPaginatedResult<TResult, TError> = Omit<\n  UseQueryResult<TResult, TError>,\n  'data'\n> &\n  QueryCacheFunctions<TResult>\n\nexport function usePaginatedQuery<\n  T extends AsyncFunc,\n  TResult = PromiseReturnType<T>,\n  TError = unknown,\n  TSelectedData = TResult\n>(\n  queryFn: T,\n  params: FirstParam<T>,\n  options?: UseQueryOptions<TResult, TError, TSelectedData> &\n    QueryNonLazyOptions\n): [TSelectedData, RestPaginatedResult<TSelectedData, TError>]\nexport function usePaginatedQuery<\n  T extends AsyncFunc,\n  TResult = PromiseReturnType<T>,\n  TError = unknown,\n  TSelectedData = TResult\n>(\n  queryFn: T,\n  params: FirstParam<T>,\n  options: UseQueryOptions<TResult, TError, TSelectedData> & QueryLazyOptions\n): [TSelectedData | undefined, RestPaginatedResult<TSelectedData, TError>]\nexport function usePaginatedQuery<\n  T extends AsyncFunc,\n  TResult = PromiseReturnType<T>,\n  TError = unknown,\n  TSelectedData = TResult\n>(\n  queryFn: T,\n  params: FirstParam<T>,\n  options: UseQueryOptions<TResult, TError, TSelectedData> = {}\n) {\n  if (typeof queryFn === 'undefined') {\n    throw new Error(\n      'usePaginatedQuery is missing the first argument - it must be a query function'\n    )\n  }\n\n  const suspenseEnabled = Boolean(process.env.__BLITZ_SUSPENSE_ENABLED)\n  let enabled =\n    isServer && suspenseEnabled\n      ? false\n      : options?.enabled ?? options?.enabled !== null\n  const suspense = enabled === false ? false : options?.suspense\n\n  const session = useSession({ suspense })\n  if (session.isLoading) {\n    enabled = false\n  }\n\n  const routerIsReady = useRouter().isReady || (isServer && suspenseEnabled)\n  const enhancedResolverRpcClient = sanitizeQuery(queryFn)\n  const queryKey = getQueryKey(queryFn, params)\n\n  const { data, ...queryRest } = useReactQuery({\n    queryKey: routerIsReady ? queryKey : ['_routerNotReady_'],\n    queryFn: routerIsReady\n      ? () => enhancedResolverRpcClient(params, { fromQueryHook: true })\n      : (emptyQueryFn as any),\n    ...options,\n    keepPreviousData: true,\n    enabled,\n  })\n\n  if (\n    queryRest.isIdle &&\n    isServer &&\n    suspenseEnabled !== false &&\n    !data &&\n    (!options || !('suspense' in options) || options.suspense) &&\n    (!options || !('enabled' in options) || options.enabled)\n  ) {\n    throw new Promise(() => {})\n  }\n\n  const rest = {\n    ...queryRest,\n    ...getQueryCacheFunctions<FirstParam<T>, TResult, T>(queryFn, params),\n  }\n\n  // return [data, rest as RestPaginatedResult<TResult>]\n  return [data, rest]\n}\n\n// -------------------------\n// useInfiniteQuery\n// -------------------------\ninterface RestInfiniteResult<TResult, TError>\n  extends Omit<UseInfiniteQueryResult<TResult, TError>, 'data'>,\n    QueryCacheFunctions<TResult> {\n  pageParams: any\n}\n\ninterface InfiniteQueryConfig<TResult, TError, TSelectedData>\n  extends UseInfiniteQueryOptions<TResult, TError, TSelectedData, TResult> {\n  // getPreviousPageParam?: (lastPage: TResult, allPages: TResult[]) => TGetPageParamResult\n  // getNextPageParam?: (lastPage: TResult, allPages: TResult[]) => TGetPageParamResult\n}\n\nexport function useInfiniteQuery<\n  T extends AsyncFunc,\n  TResult = PromiseReturnType<T>,\n  TError = unknown,\n  TSelectedData = TResult\n>(\n  queryFn: T,\n  getQueryParams: (pageParam: any) => FirstParam<T>,\n  options: InfiniteQueryConfig<TResult, TError, TSelectedData> &\n    QueryNonLazyOptions\n): [TSelectedData[], RestInfiniteResult<TSelectedData, TError>]\nexport function useInfiniteQuery<\n  T extends AsyncFunc,\n  TResult = PromiseReturnType<T>,\n  TError = unknown,\n  TSelectedData = TResult\n>(\n  queryFn: T,\n  getQueryParams: (pageParam: any) => FirstParam<T>,\n  options: InfiniteQueryConfig<TResult, TError, TSelectedData> &\n    QueryLazyOptions\n): [TSelectedData[] | undefined, RestInfiniteResult<TSelectedData, TError>]\nexport function useInfiniteQuery<\n  T extends AsyncFunc,\n  TResult = PromiseReturnType<T>,\n  TError = unknown,\n  TSelectedData = TResult\n>(\n  queryFn: T,\n  getQueryParams: (pageParam: any) => FirstParam<T>,\n  options: InfiniteQueryConfig<TResult, TError, TSelectedData>\n) {\n  if (typeof queryFn === 'undefined') {\n    throw new Error(\n      'useInfiniteQuery is missing the first argument - it must be a query function'\n    )\n  }\n\n  const suspenseEnabled = Boolean(process.env.__BLITZ_SUSPENSE_ENABLED)\n  let enabled =\n    isServer && suspenseEnabled\n      ? false\n      : options?.enabled ?? options?.enabled !== null\n  const suspense = enabled === false ? false : options?.suspense\n  const session = useSession({ suspense })\n  if (session.isLoading) {\n    enabled = false\n  }\n\n  const routerIsReady = useRouter().isReady || (isServer && suspenseEnabled)\n  const enhancedResolverRpcClient = sanitizeQuery(queryFn)\n  const queryKey = getInfiniteQueryKey(queryFn, getQueryParams)\n\n  const { data, ...queryRest } = useInfiniteReactQuery({\n    // we need an extra cache key for infinite loading so that the cache for\n    // for this query is stored separately since the hook result is an array of results.\n    // Without this cache for usePaginatedQuery and this will conflict and break.\n    queryKey: routerIsReady ? queryKey : ['_routerNotReady_'],\n    queryFn: routerIsReady\n      ? ({ pageParam }) =>\n          enhancedResolverRpcClient(getQueryParams(pageParam), {\n            fromQueryHook: true,\n          })\n      : (emptyQueryFn as any),\n    ...options,\n    enabled,\n  })\n\n  if (\n    queryRest.isIdle &&\n    isServer &&\n    suspenseEnabled !== false &&\n    !data &&\n    (!options || !('suspense' in options) || options.suspense) &&\n    (!options || !('enabled' in options) || options.enabled)\n  ) {\n    throw new Promise(() => {})\n  }\n\n  const rest = {\n    ...queryRest,\n    ...getQueryCacheFunctions<FirstParam<T>, TResult, T>(\n      queryFn,\n      getQueryParams\n    ),\n    pageParams: data?.pageParams,\n  }\n\n  return [data?.pages as any, rest]\n}\n\n// -------------------------------------------------------------------\n//                       useMutation\n// -------------------------------------------------------------------\n\n/*\n * We have to override react-query's MutationFunction and MutationResultPair\n * types so because we have throwOnError:true by default. And by the RQ types\n * have the mutate function result typed as TData|undefined which isn't typed\n * properly with throwOnError.\n *\n * So this fixes that.\n */\nexport declare type MutateFunction<\n  TData,\n  TError = unknown,\n  TVariables = unknown,\n  TContext = unknown\n> = (\n  variables?: TVariables,\n  config?: MutateOptions<TData, TError, TVariables, TContext>\n) => Promise<TData>\n\nexport declare type MutationResultPair<TData, TError, TVariables, TContext> = [\n  MutateFunction<TData, TError, TVariables, TContext>,\n  Omit<UseMutationResult<TData, TError>, 'mutate' | 'mutateAsync'>\n]\n\nexport declare type MutationFunction<TData, TVariables = unknown> = (\n  variables: TVariables,\n  ctx?: any\n) => Promise<TData>\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  mutationResolver: MutationFunction<TData, TVariables>,\n  config?: UseMutationOptions<TData, TError, TVariables, TContext>\n): MutationResultPair<TData, TError, TVariables, TContext> {\n  const enhancedResolverRpcClient = sanitizeMutation(mutationResolver)\n\n  const { mutate, mutateAsync, ...rest } = useReactQueryMutation<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >(\n    (variables) =>\n      enhancedResolverRpcClient(variables, { fromQueryHook: true }),\n    {\n      throwOnError: true,\n      ...config,\n    } as any\n  )\n\n  return [mutateAsync, rest] as MutationResultPair<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >\n}\n"],"names":[],"mappings":"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"}