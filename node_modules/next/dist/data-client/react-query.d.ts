import { UseInfiniteQueryOptions, UseInfiniteQueryResult, UseQueryOptions, UseQueryResult, MutateOptions, UseMutationOptions, UseMutationResult } from 'react-query';
import { FirstParam, PromiseReturnType, AsyncFunc } from '../types/utils';
import { QueryCacheFunctions } from './react-query-utils';
declare type QueryLazyOptions = {
    suspense: unknown;
} | {
    enabled: unknown;
};
declare type QueryNonLazyOptions = {
    suspense: true;
    enabled?: never;
} | {
    suspense?: never;
    enabled: true;
} | {
    suspense: true;
    enabled: true;
} | {
    suspense?: never;
    enabled?: never;
};
declare type RestQueryResult<TResult, TError> = Omit<UseQueryResult<TResult, TError>, 'data'> & QueryCacheFunctions<TResult>;
export declare function useQuery<T extends AsyncFunc, TResult = PromiseReturnType<T>, TError = unknown, TSelectedData = TResult>(queryFn: T, params: FirstParam<T>, options?: UseQueryOptions<TResult, TError, TSelectedData> & QueryNonLazyOptions): [TSelectedData, RestQueryResult<TSelectedData, TError>];
export declare function useQuery<T extends AsyncFunc, TResult = PromiseReturnType<T>, TError = unknown, TSelectedData = TResult>(queryFn: T, params: FirstParam<T>, options: UseQueryOptions<TResult, TError, TSelectedData> & QueryLazyOptions): [TSelectedData | undefined, RestQueryResult<TSelectedData, TError>];
declare type RestPaginatedResult<TResult, TError> = Omit<UseQueryResult<TResult, TError>, 'data'> & QueryCacheFunctions<TResult>;
export declare function usePaginatedQuery<T extends AsyncFunc, TResult = PromiseReturnType<T>, TError = unknown, TSelectedData = TResult>(queryFn: T, params: FirstParam<T>, options?: UseQueryOptions<TResult, TError, TSelectedData> & QueryNonLazyOptions): [TSelectedData, RestPaginatedResult<TSelectedData, TError>];
export declare function usePaginatedQuery<T extends AsyncFunc, TResult = PromiseReturnType<T>, TError = unknown, TSelectedData = TResult>(queryFn: T, params: FirstParam<T>, options: UseQueryOptions<TResult, TError, TSelectedData> & QueryLazyOptions): [TSelectedData | undefined, RestPaginatedResult<TSelectedData, TError>];
interface RestInfiniteResult<TResult, TError> extends Omit<UseInfiniteQueryResult<TResult, TError>, 'data'>, QueryCacheFunctions<TResult> {
    pageParams: any;
}
interface InfiniteQueryConfig<TResult, TError, TSelectedData> extends UseInfiniteQueryOptions<TResult, TError, TSelectedData, TResult> {
}
export declare function useInfiniteQuery<T extends AsyncFunc, TResult = PromiseReturnType<T>, TError = unknown, TSelectedData = TResult>(queryFn: T, getQueryParams: (pageParam: any) => FirstParam<T>, options: InfiniteQueryConfig<TResult, TError, TSelectedData> & QueryNonLazyOptions): [TSelectedData[], RestInfiniteResult<TSelectedData, TError>];
export declare function useInfiniteQuery<T extends AsyncFunc, TResult = PromiseReturnType<T>, TError = unknown, TSelectedData = TResult>(queryFn: T, getQueryParams: (pageParam: any) => FirstParam<T>, options: InfiniteQueryConfig<TResult, TError, TSelectedData> & QueryLazyOptions): [TSelectedData[] | undefined, RestInfiniteResult<TSelectedData, TError>];
export declare type MutateFunction<TData, TError = unknown, TVariables = unknown, TContext = unknown> = (variables?: TVariables, config?: MutateOptions<TData, TError, TVariables, TContext>) => Promise<TData>;
export declare type MutationResultPair<TData, TError, TVariables, TContext> = [
    MutateFunction<TData, TError, TVariables, TContext>,
    Omit<UseMutationResult<TData, TError>, 'mutate' | 'mutateAsync'>
];
export declare type MutationFunction<TData, TVariables = unknown> = (variables: TVariables, ctx?: any) => Promise<TData>;
export declare function useMutation<TData = unknown, TError = unknown, TVariables = void, TContext = unknown>(mutationResolver: MutationFunction<TData, TVariables>, config?: UseMutationOptions<TData, TError, TVariables, TContext>): MutationResultPair<TData, TError, TVariables, TContext>;
export {};
