"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getQueryKey = getQueryKey;
exports.getInfiniteQueryKey = getInfiniteQueryKey;
exports.invalidateQuery = invalidateQuery;
exports.setQueryData = setQueryData;
exports.sanitizeMutation = exports.sanitizeQuery = exports.initializeQueryClient = exports.emptyQueryFn = exports.getQueryCacheFunctions = exports.queryClient = exports.getQueryKeyFromUrlAndParams = exports.validateQueryFn = void 0;
var _reactQuery = require("react-query");
var _superjson = require("superjson");
var _index = require("../stdlib/index");
var _requestIdleCallback = require("../client/request-idle-callback");
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {
        };
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}
const initializeQueryClient = ()=>{
    let suspenseEnabled = true;
    if (!process.env.CLI_COMMAND_CONSOLE && !process.env.CLI_COMMAND_DB) {
        suspenseEnabled = Boolean(process.env.__BLITZ_SUSPENSE_ENABLED);
    }
    return new _reactQuery.QueryClient({
        defaultOptions: {
            queries: _objectSpread({
            }, _index.isServer && {
                cacheTime: 0
            }, {
                suspense: suspenseEnabled,
                retry: (failureCount, error)=>{
                    if (process.env.NODE_ENV !== 'production') return false;
                    // Retry (max. 3 times) only if network error detected
                    if (error.message === 'Network request failed' && failureCount <= 3) return true;
                    return false;
                }
            })
        }
    });
};
exports.initializeQueryClient = initializeQueryClient;
const queryClient = initializeQueryClient();
exports.queryClient = queryClient;
function isRpcClient(f) {
    return !!f._isRpcClient;
}
const getQueryCacheFunctions = (resolver, params)=>({
        setQueryData: (newData, opts = {
            refetch: true
        })=>{
            return setQueryData(resolver, params, newData, opts);
        }
    })
;
exports.getQueryCacheFunctions = getQueryCacheFunctions;
const emptyQueryFn = (()=>{
    const fn = ()=>new Promise(()=>{
        })
    ;
    fn._isRpcClient = true;
    return fn;
})();
exports.emptyQueryFn = emptyQueryFn;
const isNotInUserTestEnvironment = ()=>{
    if (process.env.JEST_WORKER_ID === undefined) return true;
    if (process.env.BLITZ_TEST_ENVIRONMENT !== undefined) return true;
    return false;
};
const validateQueryFn = (queryFn)=>{
    if (_index.isClient && !isRpcClient(queryFn) && isNotInUserTestEnvironment()) {
        throw new Error(`Either the file path to your resolver is incorrect (must be in a "queries" or "mutations" folder that isn't nested inside "pages" or "api") or you are trying to use Blitz's useQuery to fetch from third-party APIs (to do that, import useQuery directly from "react-query")`);
    }
};
exports.validateQueryFn = validateQueryFn;
const sanitize = (type)=>(queryFn)=>{
        if (_index.isServer) return queryFn;
        validateQueryFn(queryFn);
        const rpcClient = queryFn;
        const queryFnName = type === 'mutation' ? 'useMutation' : 'useQuery';
        if (rpcClient._resolverType !== type && isNotInUserTestEnvironment()) {
            throw new Error(`"${queryFnName}" was expected to be called with a ${type} but was called with a "${rpcClient._resolverType}"`);
        }
        return rpcClient;
    }
;
const sanitizeQuery = sanitize('query');
exports.sanitizeQuery = sanitizeQuery;
const sanitizeMutation = sanitize('mutation');
exports.sanitizeMutation = sanitizeMutation;
const getQueryKeyFromUrlAndParams = (url, params)=>{
    const queryKey = [
        url
    ];
    const args = typeof params === 'function' ? params() : params;
    queryKey.push((0, _superjson).serialize(args));
    return queryKey;
};
exports.getQueryKeyFromUrlAndParams = getQueryKeyFromUrlAndParams;
function getQueryKey(resolver, params) {
    if (typeof resolver === 'undefined') {
        throw new Error('getQueryKey is missing the first argument - it must be a resolver function');
    }
    return getQueryKeyFromUrlAndParams(sanitizeQuery(resolver)._routePath, params);
}
function getInfiniteQueryKey(resolver, params) {
    if (typeof resolver === 'undefined') {
        throw new Error('getInfiniteQueryKey is missing the first argument - it must be a resolver function');
    }
    const queryKey = getQueryKeyFromUrlAndParams(sanitizeQuery(resolver)._routePath, params);
    return [
        ...queryKey,
        'infinite'
    ];
}
function invalidateQuery(resolver, params) {
    if (typeof resolver === 'undefined') {
        throw new Error('invalidateQuery is missing the first argument - it must be a resolver function');
    }
    const fullQueryKey = getQueryKey(resolver, params);
    let queryKey;
    if (params) {
        queryKey = fullQueryKey;
    } else {
        // Params not provided, only use first query key item (url)
        queryKey = fullQueryKey[0];
    }
    return queryClient.invalidateQueries(queryKey);
}
function setQueryData(resolver, params, newData, opts = {
    refetch: true
}) {
    if (typeof resolver === 'undefined') {
        throw new Error('setQueryData is missing the first argument - it must be a resolver function');
    }
    const queryKey = getQueryKey(resolver, params);
    return new Promise((res)=>{
        queryClient.setQueryData(queryKey, newData);
        let result;
        if (opts.refetch) {
            result = invalidateQuery(resolver, params);
        }
        if (_index.isClient) {
            // Fix for https://github.com/blitz-js/blitz/issues/1174
            (0, _requestIdleCallback).requestIdleCallback(()=>{
                res(result);
            });
        } else {
            res(result);
        }
    });
}

//# sourceMappingURL=react-query-utils.js.map