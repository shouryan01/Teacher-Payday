"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildRpcResolver = buildRpcResolver;
exports.buildRpcClient = buildRpcClient;
var _router = require("../shared/lib/router/router");
var _superjson = require("superjson");
var _auth = require("./auth");
var _constants = require("./constants");
var _index = require("../stdlib/index");
var _reactQueryUtils = require("./react-query-utils");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
const debug = require('debug')('blitz:rpc');
function buildRpcResolver(resolver, { resolverName , resolverType , routePath , middleware  }) {
    const rpcResolver = resolver;
    const fullRoutePath = (0, _router).normalizeApiRoute(routePath);
    rpcResolver.middleware = middleware;
    rpcResolver._isRpcClient = true;
    rpcResolver._resolverName = resolverName;
    rpcResolver._resolverType = resolverType;
    rpcResolver._routePath = fullRoutePath;
    return rpcResolver;
}
function buildRpcClient({ resolverName , resolverType , routePath  }) {
    const fullRoutePath = (0, _router).normalizeApiRoute(routePath);
    const httpClient = _asyncToGenerator(function*(params, opts = {
    }) {
        if (!opts.fromQueryHook && !opts.fromInvoke) {
            console.warn('[Deprecation] Directly calling queries/mutations is deprecated in favor of invoke(queryFn, params)');
        }
        if (_index.isServer) {
            return Promise.resolve(); // as CancellablePromise<TResult>
        }
        debug('Starting request for', fullRoutePath, 'with', params, 'and', opts);
        const headers = {
            'Content-Type': 'application/json'
        };
        const antiCSRFToken = (0, _auth).getAntiCSRFToken();
        if (antiCSRFToken) {
            debug('Adding antiCSRFToken cookie header', antiCSRFToken);
            headers[_constants.HEADER_CSRF] = antiCSRFToken;
        } else {
            debug('No antiCSRFToken cookie found');
        }
        let serialized;
        if (opts.alreadySerialized) {
            // params is already serialized with superjson when it gets here
            // We have to serialize the params before passing to react-query in the query key
            // because otherwise react-query will use JSON.parse(JSON.stringify)
            // so by the time the arguments come here the real JS objects are lost
            serialized = params;
        } else {
            serialized = (0, _superjson).serialize(params);
        }
        // Create a new AbortController instance for this request
        const controller = new AbortController();
        const promise = window.fetch(fullRoutePath, {
            method: 'POST',
            headers,
            credentials: 'include',
            redirect: 'follow',
            body: JSON.stringify({
                params: serialized.json,
                meta: {
                    params: serialized.meta
                }
            }),
            signal: controller.signal
        }).then(_asyncToGenerator(function*(response) {
            debug('Received request for', routePath);
            if (response.headers) {
                if (response.headers.get(_constants.HEADER_PUBLIC_DATA_TOKEN)) {
                    (0, _auth).getPublicDataStore().updateState();
                    debug('Public data updated');
                }
                if (response.headers.get(_constants.HEADER_SESSION_CREATED)) {
                    // This also runs on logout, because on logout a new anon session is created
                    debug('Session created');
                    setTimeout(_asyncToGenerator(function*() {
                        // Do these in the next tick to prevent various bugs like https://github.com/blitz-js/blitz/issues/2207
                        debug('Invalidating react-query cache...');
                        yield _reactQueryUtils.queryClient.cancelQueries();
                        yield _reactQueryUtils.queryClient.resetQueries();
                        _reactQueryUtils.queryClient.getMutationCache().clear();
                    // We have a 100ms delay here to prevent unnecessary stale queries from running
                    // This prevents the case where you logout on a page with
                    // Page.authenticate = {redirectTo: '/login'}
                    // Without this delay, queries that require authentication on the original page
                    // will still run (but fail because you are now logged out)
                    // Ref: https://github.com/blitz-js/blitz/issues/1935
                    }), 100);
                }
                if (response.headers.get(_constants.HEADER_CSRF_ERROR)) {
                    const err = new _index.CSRFTokenMismatchError();
                    err.stack = null;
                    throw err;
                }
            }
            if (!response.ok) {
                const error = new Error(response.statusText);
                error.statusCode = response.status;
                error.path = routePath;
                error.stack = null;
                throw error;
            } else {
                let payload;
                try {
                    payload = yield response.json();
                } catch (error) {
                    const err = new Error(`Failed to parse json from ${routePath}`);
                    err.stack = null;
                    throw err;
                }
                if (payload.error) {
                    var ref;
                    let error = (0, _superjson).deserialize({
                        json: payload.error,
                        meta: (ref = payload.meta) === null || ref === void 0 ? void 0 : ref.error
                    });
                    // We don't clear the publicDataStore for anonymous users,
                    // because there is not sensitive data
                    if (error.name === 'AuthenticationError' && (0, _auth).getPublicDataStore().getData().userId) {
                        (0, _auth).getPublicDataStore().clear();
                    }
                    const prismaError = error.message.match(/invalid.*prisma.*invocation/i);
                    if (prismaError && !('code' in error)) {
                        error = new Error(prismaError[0]);
                        error.statusCode = 500;
                    }
                    error.stack = null;
                    throw error;
                } else {
                    var ref;
                    const data = (0, _superjson).deserialize({
                        json: payload.result,
                        meta: (ref = payload.meta) === null || ref === void 0 ? void 0 : ref.result
                    });
                    if (!opts.fromQueryHook) {
                        const queryKey = (0, _reactQueryUtils).getQueryKeyFromUrlAndParams(routePath, params);
                        _reactQueryUtils.queryClient.setQueryData(queryKey, data);
                    }
                    return data;
                }
            }
        })) // as CancellablePromise<TResult>
        ;
        // Disable react-query request cancellation for now
        // Having too many weird bugs with it enabled
        // promise.cancel = () => controller.abort()
        return promise;
    });
    const rpcClient = httpClient;
    rpcClient._isRpcClient = true;
    rpcClient._resolverName = resolverName;
    rpcClient._resolverType = resolverType;
    rpcClient._routePath = fullRoutePath;
    return rpcClient;
}

//# sourceMappingURL=rpc.js.map