"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getAndValidateMiddleware = getAndValidateMiddleware;
exports.handleRequestWithMiddleware = handleRequestWithMiddleware;
exports.compose = compose;
var _logging = require("./lib/logging");
const debug = require('debug')('blitz:middleware');
function getAndValidateMiddleware(config, resolverModule, route) {
    const middleware = [];
    debug('[getAndValidateMiddleware] config.middleware', config.middleware);
    if (config.middleware) {
        if (!Array.isArray(config.middleware)) {
            throw new Error("'middleware' in blitz.config.js must be an array");
        }
        middleware.push(...config.middleware);
    }
    debug('[getAndValidateMiddleware] resolverModule.middleware', resolverModule.middleware);
    if (resolverModule.middleware) {
        if (!Array.isArray(resolverModule.middleware)) {
            throw new Error(`'middleware' exported from ${route} must be an array`);
        }
        middleware.push(...resolverModule.middleware);
    }
    return middleware;
}
async function handleRequestWithMiddleware(req, res, middleware, { throwOnError =true , stackPrintOnError =true  } = {
}) {
    const log = (0, _logging).baseLogger().getChildLogger();
    if (!res.blitzCtx) {
        res.blitzCtx = {
        };
    }
    if (!res._blitz) {
        res._blitz = {
        };
    }
    let handler = compose(middleware);
    try {
        await handler(req, res, (error)=>{
            if (error) {
                throw error;
            }
        });
    } catch (error) {
        (0, _logging).newline();
        if (res.writableFinished) {
            log.error('Error occured in middleware after the response was already sent to the browser');
        } else {
            log.error('Error while processing the request');
        }
        if (error._clearStack) {
            delete error.stack;
        }
        if (stackPrintOnError) {
            log.prettyError(error);
        } else {
            log.prettyError(error, true, false, false);
        }
        (0, _logging).newline();
        if (throwOnError) throw error;
    }
}
function compose(middleware) {
    if (!Array.isArray(middleware)) {
        throw new TypeError('Middleware stack must be an array!');
    }
    for (const handler of middleware){
        if (typeof handler !== 'function') {
            throw new TypeError('Middleware must be composed of functions!');
        }
    }
    // Return a single middleware function that composes everything passed in
    return function(req, res, next) {
        // last called middleware #
        let index = -1;
        function dispatch(i, error) {
            if (error) {
                return Promise.reject(error);
            }
            if (i <= index) throw new Error('next() called multiple times');
            index = i;
            let handler1 = middleware[i];
            if (!handler1) {
                return Promise.resolve();
            }
            try {
                debug(`[${handler1.name}] Starting handler...`);
                return Promise.resolve(handler1(req, res, dispatch.bind(null, i + 1)));
            } catch (err) {
                return Promise.reject(err);
            }
        }
        // return next(result as any)
        return dispatch(0).then(next);
    };
}

//# sourceMappingURL=middleware.js.map