"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports._postPayload = _postPayload;
var _asyncRetry = _interopRequireDefault(require("next/dist/compiled/async-retry"));
var _nodeFetch = _interopRequireDefault(require("node-fetch"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _postPayload(data) {
    let lines = '';
    function writeField(key, value) {
        if (lines[lines.length - 1] !== ' ') {
            lines += ',';
        }
        if (value === null || value === undefined) {
            lines += `${key}=false`;
        } else if (typeof value === 'object') {
            lines += `${key}="object"`;
        } else if (typeof value === 'string') {
            lines += `${key}="${value}"`;
        } else {
            lines += `${key}=${value}`;
        }
    }
    const { nextVersion: blitzVersion , ...meta } = data.meta;
    for (let event of data.events){
        // New line
        if (lines) {
            lines += '\n';
        }
        // Measurement name
        lines += event.eventName;
        // Add tags
        lines += `,blitzVersion="${blitzVersion}"`;
        // Separate tags + fields
        lines += ' ';
        // Add fields
        // from context
        for (let [key, value] of Object.entries(data.context)){
            writeField(key, value);
        }
        // from event.fields
        for (let [key1, value1] of Object.entries(event.fields)){
            writeField(key1, value1);
        }
        // from meta
        for (let [key2, value2] of Object.entries(meta)){
            writeField(key2, value2);
        }
    }
    return (0, _asyncRetry).default(()=>(0, _nodeFetch).default(`https://us-east-1-1.aws.cloud2.influxdata.com/api/v2/write?org=blitz&bucket=blitzjs`, {
            method: 'POST',
            body: lines,
            headers: {
                Authorization: 'Token Rh3i3hTSsazb8uD4tBnosOC8-vQ38Xbu13SrqRqV5ChCpvE69mmkw7KkNZQh0yEUuS0KjTgbf0ot8PnCHGfJgw=='
            },
            timeout: 5000
        }).then(async (res)=>{
            if (!res.ok) {
                const err = new Error(res.statusText);
                err.response = res;
                throw err;
            }
        })
    , {
        minTimeout: 500,
        retries: 1,
        factor: 1
    }).catch(()=>{
    // We swallow errors when telemetry cannot be sent
    })// Ensure promise is voided
    .then(()=>{
    }, ()=>{
    });
}

//# sourceMappingURL=post-payload.js.map