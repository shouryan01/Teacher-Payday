"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.collectAllRoutes = collectAllRoutes;
exports.saveRouteManifest = saveRouteManifest;
exports.parseDefaultExportName = parseDefaultExportName;
exports.generateManifest = generateManifest;
exports.parseParametersFromRoute = parseParametersFromRoute;
var _fs = require("fs");
var _entries = require("./entries");
var _utils = require("./utils");
var _logging = require("../server/lib/logging");
var _utils1 = require("../server/utils");
var _path = require("path");
var _fsExtra = require("fs-extra");
var _findUp = _interopRequireDefault(require("next/dist/compiled/find-up"));
var _resolveFrom = _interopRequireDefault(require("resolve-from"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const readFile = _fs.promises.readFile;
const manifestDebug = require('debug')('blitz:manifest');
function getVerb(type) {
    switch(type){
        case 'api':
            return '*';
        case 'rpc':
            return 'post';
        default:
            return 'get';
    }
}
// from https://github.com/angus-c/just/blob/master/packages/array-partition/index.js
function partition(arr, predicate) {
    if (!Array.isArray(arr)) {
        throw new Error('expected first argument to be an array');
    }
    if (typeof predicate != 'function') {
        throw new Error('expected second argument to be a function');
    }
    var first = [];
    var second = [];
    var length = arr.length;
    for(var i = 0; i < length; i++){
        var nextValue = arr[i];
        if (predicate(nextValue)) {
            first.push(nextValue);
        } else {
            second.push(nextValue);
        }
    }
    return [
        first,
        second
    ];
}
const apiPathRegex = /([\\/]api[\\/])/;
async function collectAllRoutes(directory, config) {
    const routeFiles = await (0, _utils).collectPages(directory, config.pageExtensions);
    const rawRouteMappings = (0, _entries).createPagesMapping(routeFiles, config.pageExtensions);
    const routes = [];
    for (const [route, filePath] of Object.entries(rawRouteMappings)){
        if ([
            '/_app',
            '/_document',
            '/_error'
        ].includes(route)) continue;
        let type;
        if ((0, _utils).getIsRpcFile(filePath)) {
            type = 'rpc';
        } else if (apiPathRegex.test(filePath)) {
            type = 'api';
        } else {
            type = 'page';
        }
        routes.push({
            filePath: filePath.replace('private-next-pages/', ''),
            route,
            type,
            verb: getVerb(type)
        });
    }
    return routes;
}
const pascalCase = (value)=>{
    const val = value.replace(/[-_\s/.]+(.)?/g, (_match, chr)=>chr ? chr.toUpperCase() : ''
    );
    return val.substr(0, 1).toUpperCase() + val.substr(1);
};
async function saveRouteManifest(directory, config) {
    const allRoutes = await collectAllRoutes(directory, config);
    const routes = {
    };
    for (let { filePath , route , type  } of allRoutes){
        if (type === 'api' || type === 'rpc') continue;
        if (/\.mdx$/.test(filePath)) {
            routes[route] = {
                ...parseParametersFromRoute(route),
                name: route === '/' ? 'Index' : pascalCase(route),
                mdx: true
            };
        } else {
            const fileContents = await readFile((0, _path).join(directory, filePath), {
                encoding: 'utf-8'
            });
            const defaultExportName = parseDefaultExportName(fileContents);
            if (!defaultExportName) continue;
            routes[route] = {
                ...parseParametersFromRoute(route),
                name: defaultExportName
            };
        }
    }
    const { declaration , implementation  } = generateManifest(routes);
    const dotBlitz = (0, _path).join(await findNodeModulesRoot(directory), '.blitz');
    await (0, _fsExtra).outputFile((0, _path).join(dotBlitz, 'index.js'), implementation, {
        encoding: 'utf-8'
    });
    await (0, _fsExtra).outputFile((0, _path).join(dotBlitz, 'index-browser.js'), implementation, {
        encoding: 'utf-8'
    });
    await (0, _fsExtra).outputFile((0, _path).join(dotBlitz, 'index.d.ts'), declaration, {
        encoding: 'utf-8'
    });
}
async function findNodeModulesRoot(src) {
    /*
   *  Because of our package structure, and because of how things like pnpm link modules,
   *  we must first find blitz package, and then find `next` and then
   *  the root of `next`
   *
   *  This is because we import from `.blitz` inside `next/stdlib`.
   *  If that changes, then this logic here will need to change
   */ manifestDebug('src ' + src);
    let root;
    if (process.env.NEXT_PNPM_TEST) {
        var ref;
        const nextPkgLocation = (0, _path).dirname((ref = await (0, _findUp).default('package.json', {
            cwd: (0, _resolveFrom).default(src, 'next')
        })) !== null && ref !== void 0 ? ref : '');
        manifestDebug('nextPkgLocation ' + nextPkgLocation);
        if (!nextPkgLocation) {
            throw new Error("Internal Blitz Error: unable to find 'next' package location");
        }
        root = (0, _path).join(nextPkgLocation, '../');
    } else if (_utils1.isInternalBlitzMonorepoDevelopment) {
        root = (0, _path).join(src, 'node_modules');
    } else {
        var ref;
        const blitzPkgLocation = (0, _path).dirname((ref = await (0, _findUp).default('package.json', {
            cwd: (0, _resolveFrom).default(src, 'blitz')
        })) !== null && ref !== void 0 ? ref : '');
        manifestDebug('blitzPkgLocation ' + blitzPkgLocation);
        if (!blitzPkgLocation) {
            throw new Error("Internal Blitz Error: unable to find 'blitz' package location");
        }
        var ref1;
        const nextPkgLocation = (0, _path).dirname((ref1 = await (0, _findUp).default('package.json', {
            cwd: (0, _resolveFrom).default(blitzPkgLocation, 'next')
        })) !== null && ref1 !== void 0 ? ref1 : '');
        manifestDebug('nextPkgLocation ' + nextPkgLocation);
        if (!nextPkgLocation) {
            throw new Error("Internal Blitz Error: unable to find 'next' package location");
        }
        root = (0, _path).join(nextPkgLocation, '../');
        if (root.endsWith('@blitzjs/')) {
            root = (0, _path).join(nextPkgLocation, '../../');
        }
    }
    manifestDebug('root ' + root);
    return root;
}
function parseDefaultExportName(contents) {
    const result = contents.match(/export\s+default(?:\s+(?:const|let|class|var|function))?\s+(\w+)/);
    if (!result) {
        return null;
    }
    var ref2;
    return (ref2 = result[1]) !== null && ref2 !== void 0 ? ref2 : null;
}
function dedupeBy(arr, by) {
    const allKeys = arr.map(by);
    const countKeys = allKeys.reduce((obj, key)=>({
            ...obj,
            [key]: (obj[key] || 0) + 1
        })
    , {
    });
    const duplicateKeys = Object.keys(countKeys).filter((key)=>countKeys[key] > 1
    );
    if (duplicateKeys.length) {
        (0, _logging).newline();
        const log = (0, _logging).baseLogger({
            displayDateTime: false
        }).getChildLogger();
        duplicateKeys.forEach((key)=>{
            let errorMessage = `The page component is named "${key}" on the following routes:\n\n`;
            arr.filter((v)=>by(v) === key
            ).forEach(([route])=>{
                errorMessage += `\t${route}\n`;
            });
            log.error(errorMessage);
        });
        console.error('The page component must have a unique name across all routes, so change the component names so they are all unique.\n');
        // Don't throw error in internal monorepo development because existing nextjs
        // integration tests all have duplicate page names
        if (process.env.NODE_ENV === 'production' && !_utils1.isInternalBlitzMonorepoDevelopment) {
            const error = Error('Duplicate Page Name');
            delete error.stack;
            throw error;
        }
    }
    return arr.filter((v)=>!duplicateKeys.includes(by(v))
    );
}
function generateManifest(routes) {
    const routesWithoutDuplicates = dedupeBy(Object.entries(routes), ([_path1, { name  }])=>name
    );
    const implementationLines = routesWithoutDuplicates.map(([path, { name  }])=>`${name}: (query) => ({ pathname: "${path}", query })`
    );
    const declarationLines = routesWithoutDuplicates.map(([_path1, { name , parameters , multipleParameters  }])=>{
        if (parameters.length === 0 && multipleParameters.length === 0) {
            return `${name}(query?: ParsedUrlQueryInput): RouteUrlObject`;
        }
        return `${name}(query: { ${[
            ...parameters.map((param)=>param.name + (param.optional ? '?' : '') + ': string | number'
            ),
            ...multipleParameters.map((param)=>param.name + (param.optional ? '?' : '') + ': (string | number)[]'
            ), 
        ].join('; ')} } & ParsedUrlQueryInput): RouteUrlObject`;
    });
    const declarationEnding = declarationLines.length > 0 ? ';' : '';
    const moduleName = process.env.NEXT_PNPM_TEST ? 'next/types' : 'blitz';
    return {
        implementation: 'exports.Routes = {\n' + implementationLines.map((line)=>'  ' + line
        ).join(',\n') + '\n}',
        declaration: `
import type { ParsedUrlQueryInput } from "querystring"
import type { RouteUrlObject } from "${moduleName}"

export const Routes: {
${declarationLines.map((line)=>'  ' + line
        ).join(';\n') + declarationEnding}
}`.trim()
    };
}
function removeSquareBracketsFromSegments(value) {
    if (typeof value === 'string') {
        return value.replace('[', '').replace(']', '');
    }
    return value.map((val)=>val.replace('[', '').replace(']', '')
    );
}
const squareBracketsRegex = /\[\[.*?\]\]|\[.*?\]/g;
function parseParametersFromRoute(path) {
    var ref2;
    const parameteredSegments = (ref2 = path.match(squareBracketsRegex)) !== null && ref2 !== void 0 ? ref2 : [];
    const withoutBrackets = removeSquareBracketsFromSegments(parameteredSegments);
    const [multipleParameters, parameters] = partition(withoutBrackets, (p)=>p.includes('...')
    );
    return {
        parameters: parameters.map((value)=>{
            const containsSquareBrackets = squareBracketsRegex.test(value);
            if (containsSquareBrackets) {
                return {
                    name: removeSquareBracketsFromSegments(value),
                    optional: true
                };
            }
            return {
                name: value,
                optional: false
            };
        }),
        multipleParameters: multipleParameters.map((param)=>{
            const withoutEllipsis = param.replace('...', '');
            const containsSquareBrackets = squareBracketsRegex.test(withoutEllipsis);
            if (containsSquareBrackets) {
                return {
                    name: removeSquareBracketsFromSegments(withoutEllipsis),
                    optional: true
                };
            }
            return {
                name: withoutEllipsis,
                optional: false
            };
        })
    };
}

//# sourceMappingURL=routes.js.map