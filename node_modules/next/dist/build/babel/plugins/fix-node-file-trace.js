"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperModuleImports = require("@babel/helper-module-imports");
var _types = require("@babel/types");
var nodePath = _interopRequireWildcard(require("path"));
var _utils = require("./utils");
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {
        };
        if (obj != null) {
            for(var key in obj){
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {
                    };
                    if (desc.get || desc.set) {
                        Object.defineProperty(newObj, key, desc);
                    } else {
                        newObj[key] = obj[key];
                    }
                }
            }
        }
        newObj.default = obj;
        return newObj;
    }
}
function functionDeclarationToExpression(declaration) {
    return (0, _types).functionExpression(declaration.id, declaration.params, declaration.body, declaration.generator, declaration.async);
}
const functionsToReplace = [
    'getServerSideProps',
    'getStaticProps'
];
function transformPropGetters(path, transform) {
    const { node  } = path;
    if ((0, _types).isFunctionDeclaration(node.declaration)) {
        const { id: functionId  } = node.declaration;
        if (!functionId) {
            return;
        }
        if (!functionsToReplace.includes(functionId.name)) {
            return;
        }
        node.declaration = (0, _types).variableDeclaration('const', [
            (0, _types).variableDeclarator(functionId, transform(functionDeclarationToExpression(node.declaration))), 
        ]);
        return;
    }
    if ((0, _types).isVariableDeclaration(node.declaration)) {
        node.declaration.declarations.forEach((declaration)=>{
            if ((0, _types).isIdentifier(declaration.id) && functionsToReplace.includes(declaration.id.name) && declaration.init) {
                declaration.init = transform(declaration.init);
            }
        });
    }
}
const HOFName = 'withFixNodeFileTrace';
const importFrom = 'next/dist/server/utils';
function addWithFixNodeFileTraceImport(path) {
    return (0, _helperModuleImports).addNamed(path, HOFName, importFrom);
}
const pagesToSkip = [].concat(...[
    '_app',
    '_document',
    '_error'
].map((name)=>[
        name + '.js',
        name + '.jsx',
        name + '.ts',
        name + '.tsx', 
    ]
));
function isPage(filePath) {
    if (!filePath.includes(nodePath.sep + 'pages' + nodePath.sep)) {
        return false;
    }
    if (filePath.includes(nodePath.sep + 'pages' + nodePath.sep + 'api' + nodePath.sep)) {
        return false;
    }
    return !pagesToSkip.some((fileToSkip)=>filePath.includes(fileToSkip)
    );
}
function isApiRoute(filePath) {
    if (filePath.includes(nodePath.sep + 'api' + nodePath.sep)) {
        return true;
    }
    return false;
}
function FixNodeFileTrace() {
    return {
        name: 'FixNodeFileTrace',
        visitor: {
            Program (path, state) {
                var ref;
                const filePath = (ref = (0, _utils).getFileName(state)) !== null && ref !== void 0 ? ref : nodePath.join('pages', 'Default.js');
                if (isPage(filePath)) {
                    const body = path.get('body');
                    body.filter((node)=>(0, _types).isExportNamedDeclaration(node)
                    ).forEach((node)=>{
                        transformPropGetters(node, (decl)=>{
                            return (0, _types).callExpression(addWithFixNodeFileTraceImport(node), [
                                decl, 
                            ]);
                        });
                    });
                    return;
                } else if (isApiRoute(filePath)) {
                    const body = path.get('body');
                    const exportDefaultDeclaration = body.find((node)=>(0, _types).isExportDefaultDeclaration(node)
                    );
                    if (exportDefaultDeclaration) {
                        (0, _utils).wrapExportDefaultDeclaration(exportDefaultDeclaration, HOFName, importFrom);
                        return;
                    }
                }
            }
        }
    };
}
var _default = FixNodeFileTrace;
exports.default = _default;

//# sourceMappingURL=fix-node-file-trace.js.map