"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.functionDeclarationToExpression = functionDeclarationToExpression;
exports.classDeclarationToExpression = classDeclarationToExpression;
exports.getFileName = getFileName;
exports.wrapExportDefaultDeclaration = wrapExportDefaultDeclaration;
var _core = require("next/dist/compiled/babel/core");
var _helperModuleImports = require("@babel/helper-module-imports");
function functionDeclarationToExpression(declaration) {
    return _core.types.functionExpression(declaration.id, declaration.params, declaration.body, declaration.generator, declaration.async);
}
function classDeclarationToExpression(declaration) {
    return _core.types.classExpression(declaration.id, declaration.superClass, declaration.body, declaration.decorators);
}
function getFileName(state) {
    const { filename , cwd  } = state;
    if (!filename) {
        return undefined;
    }
    if (cwd && filename.startsWith(cwd)) {
        return filename.slice(cwd.length);
    }
    return filename;
}
function wrapExportDefaultDeclaration(path, HOFName, importFrom) {
    // eslint-disable-next-line no-shadow
    function wrapInHOF(path1, expr) {
        return _core.types.callExpression((0, _helperModuleImports).addNamed(path1, HOFName, importFrom), [
            expr
        ]);
    }
    const { node  } = path;
    if (_core.types.isIdentifier(node.declaration) || _core.types.isFunctionExpression(node.declaration) || _core.types.isCallExpression(node.declaration)) {
        node.declaration = wrapInHOF(path, node.declaration);
    } else if (_core.types.isFunctionDeclaration(node.declaration) || _core.types.isClassDeclaration(node.declaration)) {
        if (node.declaration.id) {
            path.insertBefore(node.declaration);
            node.declaration = wrapInHOF(path, node.declaration.id);
        } else {
            if (_core.types.isFunctionDeclaration(node.declaration)) {
                node.declaration = wrapInHOF(path, functionDeclarationToExpression(node.declaration));
            } else {
                node.declaration = wrapInHOF(path, classDeclarationToExpression(node.declaration));
            }
        }
    }
}

//# sourceMappingURL=utils.js.map