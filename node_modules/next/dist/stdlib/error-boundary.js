"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.useErrorHandler = exports.withErrorBoundary = exports.ErrorBoundary = void 0;
var _errors = require("./errors");
var React = _interopRequireWildcard(require("react"));
var _routerContext = require("../shared/lib/router-context");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {
        };
        if (obj != null) {
            for(var key in obj){
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {
                    };
                    if (desc.get || desc.set) {
                        Object.defineProperty(newObj, key, desc);
                    } else {
                        newObj[key] = obj[key];
                    }
                }
            }
        }
        newObj.default = obj;
        return newObj;
    }
}
const debug = require('debug')('blitz:errorboundary');
const changedArray = (a = [], b = [])=>a.length !== b.length || a.some((item, index)=>!Object.is(item, b[index])
    )
;
const initialState = {
    error: null
};
class ErrorBoundary extends React.Component {
    static getDerivedStateFromError(error) {
        return {
            error
        };
    }
    reset() {
        this.updatedWithError = false;
        this.setState(initialState);
    }
    componentDidCatch(error, info) {
        return _asyncToGenerator((function*() {
            var _props, ref;
            if (error instanceof _errors.RedirectError) {
                var ref1;
                debug('Redirecting from ErrorBoundary to', error.url);
                yield (ref1 = this.context) === null || ref1 === void 0 ? void 0 : ref1.push(error.url);
                return;
            }
            (ref = (_props = this.props).onError) === null || ref === void 0 ? void 0 : ref.call(_props, error, info);
        }).bind(this))();
    }
    componentDidMount() {
        var ref2, ref3;
        const { error  } = this.state;
        if (error !== null) {
            this.updatedWithError = true;
        }
        (ref2 = this.context) === null || ref2 === void 0 ? void 0 : (ref3 = ref2.events) === null || ref3 === void 0 ? void 0 : ref3.on('routeChangeComplete', this.handleRouteChange);
    }
    componentWillUnmount() {
        var ref4, ref5;
        (ref4 = this.context) === null || ref4 === void 0 ? void 0 : (ref5 = ref4.events) === null || ref5 === void 0 ? void 0 : ref5.off('routeChangeComplete', this.handleRouteChange);
    }
    componentDidUpdate(prevProps) {
        const { error  } = this.state;
        const { resetKeys  } = this.props;
        // There's an edge case where if the thing that triggered the error
        // happens to *also* be in the resetKeys array, we'd end up resetting
        // the error boundary immediately. This would likely trigger a second
        // error to be thrown.
        // So we make sure that we don't check the resetKeys on the first call
        // of cDU after the error is set
        if (error !== null && !this.updatedWithError) {
            this.updatedWithError = true;
            return;
        }
        if (error !== null && changedArray(prevProps.resetKeys, resetKeys)) {
            var _props, ref6;
            (ref6 = (_props = this.props).onResetKeysChange) === null || ref6 === void 0 ? void 0 : ref6.call(_props, prevProps.resetKeys, resetKeys);
            this.reset();
        }
    }
    render() {
        const { error  } = this.state;
        const { fallbackRender , FallbackComponent , fallback  } = this.props;
        if (error !== null) {
            const props = {
                error,
                resetErrorBoundary: this.resetErrorBoundary
            };
            if (error instanceof _errors.RedirectError) {
                // Don't render children because redirect is imminent
                return null;
            } else if (/*#__PURE__*/ React.isValidElement(fallback)) {
                return fallback;
            } else if (typeof fallbackRender === 'function') {
                return fallbackRender(props);
            } else if (FallbackComponent) {
                return(/*#__PURE__*/ React.createElement(FallbackComponent, Object.assign({
                }, props)));
            } else {
                throw new Error('<ErrorBoundary> requires either a fallback, fallbackRender, or FallbackComponent prop');
            }
        }
        return this.props.children;
    }
    constructor(...args){
        super(...args);
        this.state = initialState;
        this.updatedWithError = false;
        this.resetErrorBoundary = (...args1)=>{
            var _props, ref7;
            (ref7 = (_props = this.props).onReset) === null || ref7 === void 0 ? void 0 : ref7.call(_props, ...args1);
            this.reset();
        };
        this.handleRouteChange = ()=>{
            var _props, ref8;
            debug('Resetting error boundary on route change');
            (ref8 = (_props = this.props).onReset) === null || ref8 === void 0 ? void 0 : ref8.call(_props);
            this.reset();
        };
    }
}
ErrorBoundary.contextType = _routerContext.RouterContext;
function withErrorBoundary(Component, errorBoundaryProps) {
    const Wrapped = (props)=>{
        return(/*#__PURE__*/ React.createElement(ErrorBoundary, Object.assign({
        }, errorBoundaryProps), /*#__PURE__*/ React.createElement(Component, Object.assign({
        }, props))));
    };
    // Format for display in DevTools
    const name = Component.displayName || Component.name || 'Unknown';
    Wrapped.displayName = `withErrorBoundary(${name})`;
    return Wrapped;
}
function useErrorHandler(givenError) {
    const [error, setError] = React.useState(null);
    if (givenError != null) throw givenError;
    if (error != null) throw error;
    return setError;
}
exports.ErrorBoundary = ErrorBoundary;
exports.withErrorBoundary = withErrorBoundary;
exports.useErrorHandler = useErrorHandler;

//# sourceMappingURL=error-boundary.js.map