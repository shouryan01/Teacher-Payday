{"version":3,"sources":["../../stdlib/zod-utils.ts"],"sourcesContent":["import { ParserType } from '../types/index'\nimport { ZodError } from 'zod'\n\nexport function formatZodError(error: ZodError) {\n  if (!error || typeof error.format !== 'function') {\n    throw new Error(\n      'The argument to formatZodError must be a zod error with error.format()'\n    )\n  }\n\n  const errors = error.format()\n  return recursiveFormatZodErrors(errors)\n}\n\nexport function recursiveFormatZodErrors(errors: any) {\n  let formattedErrors: Record<string, any> = {}\n\n  for (const key in errors) {\n    if (key === '_errors') {\n      continue\n    }\n\n    if (errors[key]?._errors?.[0]) {\n      if (!isNaN(key as any) && !Array.isArray(formattedErrors)) {\n        formattedErrors = []\n      }\n      formattedErrors[key] = errors[key]._errors[0]\n    } else {\n      if (!isNaN(key as any) && !Array.isArray(formattedErrors)) {\n        formattedErrors = []\n      }\n      formattedErrors[key] = recursiveFormatZodErrors(errors[key])\n    }\n  }\n\n  return formattedErrors\n}\n\nconst validateZodSchemaSync = (schema: any): any => (values: any) => {\n  if (!schema) return {}\n  try {\n    schema.parse(values)\n    return {}\n  } catch (error: any) {\n    return error.format ? formatZodError(error) : error.toString()\n  }\n}\n\nconst validateZodSchemaAsync = (schema: any) => async (values: any) => {\n  if (!schema) return {}\n  try {\n    await schema.parseAsync(values)\n    return {}\n  } catch (error: any) {\n    return error.format ? formatZodError(error) : error.toString()\n  }\n}\n\n// type zodSchemaReturn = typeof validateZodSchemaAsync | typeof validateZodSchemaSync\n// : (((values:any) => any) | ((values:any) => Promise<any>)) =>\nexport function validateZodSchema(\n  schema: any,\n  parserType: 'sync'\n): (values: any) => any\nexport function validateZodSchema(\n  schema: any,\n  parserType: 'async'\n): (values: any) => Promise<any>\nexport function validateZodSchema(schema: any): (values: any) => Promise<any>\nexport function validateZodSchema(\n  schema: any,\n  parserType: ParserType = 'async'\n) {\n  if (parserType === 'sync') {\n    return validateZodSchemaSync(schema)\n  } else {\n    return validateZodSchemaAsync(schema)\n  }\n}\n"],"names":[],"mappings":";;;;QAGgB,cAAc,GAAd,cAAc;QAWd,wBAAwB,GAAxB,wBAAwB;QAuDxB,iBAAiB,GAAjB,iBAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SAlEjB,cAAc,CAAC,KAAe,EAAE,CAAC;IAC/C,EAAE,GAAG,KAAK,WAAW,KAAK,CAAC,MAAM,MAAK,QAAU,GAAE,CAAC;QACjD,KAAK,CAAC,GAAG,CAAC,KAAK,EACb,sEAAwE;IAE5E,CAAC;IAED,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM;WACpB,wBAAwB,CAAC,MAAM;AACxC,CAAC;SAEe,wBAAwB,CAAC,MAAW,EAAE,CAAC;IACrD,GAAG,CAAC,eAAe;;QAEd,KAAK,CAAC,GAAG,IAAI,MAAM,CAAE,CAAC;YAKrB,GAAW;QAJf,EAAE,EAAE,GAAG,MAAK,OAAS,GAAE,CAAC;;QAExB,CAAC;QAED,EAAE,GAAE,GAAW,GAAX,MAAM,CAAC,GAAG,eAAV,GAAW,UAAX,CAAoB,QAApB,CAAoB,WAApB,GAAW,CAAE,OAAO,4BAApB,CAAoB,QAApB,CAAoB,QAAG,CAAC,GAAG,CAAC;YAC9B,EAAE,GAAG,KAAK,CAAC,GAAG,MAAa,KAAK,CAAC,OAAO,CAAC,eAAe,GAAG,CAAC;gBAC1D,eAAe;YACjB,CAAC;YACD,eAAe,CAAC,GAAG,IAAI,MAAM,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;QAC9C,CAAC,MAAM,CAAC;YACN,EAAE,GAAG,KAAK,CAAC,GAAG,MAAa,KAAK,CAAC,OAAO,CAAC,eAAe,GAAG,CAAC;gBAC1D,eAAe;YACjB,CAAC;YACD,eAAe,CAAC,GAAG,IAAI,wBAAwB,CAAC,MAAM,CAAC,GAAG;QAC5D,CAAC;IACH,CAAC;WAEM,eAAe;AACxB,CAAC;AAED,KAAK,CAAC,qBAAqB,IAAI,MAAW,IAAW,MAAW,GAAK,CAAC;QACpE,EAAE,GAAG,MAAM;;YACP,CAAC;YACH,MAAM,CAAC,KAAK,CAAC,MAAM;;;QAErB,CAAC,QAAQ,KAAK,EAAO,CAAC;mBACb,KAAK,CAAC,MAAM,GAAG,cAAc,CAAC,KAAK,IAAI,KAAK,CAAC,QAAQ;QAC9D,CAAC;IACH,CAAC;;AAED,KAAK,CAAC,sBAAsB,IAAI,MAAW,+BAAY,MAAW,EAAK,CAAC;QACtE,EAAE,GAAG,MAAM;;YACP,CAAC;kBACG,MAAM,CAAC,UAAU,CAAC,MAAM;;;QAEhC,CAAC,QAAQ,KAAK,EAAO,CAAC;mBACb,KAAK,CAAC,MAAM,GAAG,cAAc,CAAC,KAAK,IAAI,KAAK,CAAC,QAAQ;QAC9D,CAAC;IACH,CAAC;;SAae,iBAAiB,CAC/B,MAAW,EACX,UAAsB,IAAG,KAAO,GAChC,CAAC;IACD,EAAE,EAAE,UAAU,MAAK,IAAM,GAAE,CAAC;eACnB,qBAAqB,CAAC,MAAM;IACrC,CAAC,MAAM,CAAC;eACC,sBAAsB,CAAC,MAAM;IACtC,CAAC;AACH,CAAC"}